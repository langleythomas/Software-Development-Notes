<!-- Essential Notes to Look At:
Books:
- The Pragmatic Programmer (Physical)
- bash Cookbook (Humble Bundle)

Online:
- AWS course

Books:
- Apprenticeship Patterns (Humble Bundle)
- Automate the Boring Stuff with Python: Practical Programming for Total Beginners (Humble Bundle)
- The Art of Agile Development (Humble Bundle)
-->

<!-- Nice Notes to Look At:
Books:
- Code Complete (Microsoft Press)
- Wicked Cool Shell Scripts
- Head First Agile
- Head First Design Patterns
- Something C-related
- Something C++-related
- Something Data Structures & Algorithms-related
- Something Security-related
-->

<!-- markdownlint-capture -->
<!-- markdownlint-disable -->
- [Book Notes](#book-notes)
  - [97 Things Every Programmer Should Know](#97-things-every-programmer-should-know)
    - [A Comment on Comments](#a-comment-on-comments)
    - [A Message to the Future](#a-message-to-the-future)
    - [Act with Prudence](#act-with-prudence)
    - [Apply Functional Programming Principles](#apply-functional-programming-principles)
    - [Ask, "What Would the User Do?" (You Are Not the User)](#ask-what-would-the-user-do-you-are-not-the-user)
    - [Automate Your Coding Standard](#automate-your-coding-standard)
    - [Beauty Is in Simplicity](#beauty-is-in-simplicity)
    - [Before You Refactor](#before-you-refactor)
    - [Beware the Share](#beware-the-share)
    - [Check Your Code First Before Looking to Blame Others](#check-your-code-first-before-looking-to-blame-others)
    - [Choose Your Tools with Care](#choose-your-tools-with-care)
    - [Code in the Language of the Domain](#code-in-the-language-of-the-domain)
    - [Code is Design](#code-is-design)
    - [Code Layout Matters](#code-layout-matters)
    - [Code Reviews](#code-reviews)
    - [Coding with Reason](#coding-with-reason)
    - [Comment Only What the Code Cannot Say](#comment-only-what-the-code-cannot-say)
    - [Continuous Learning](#continuous-learning)
    - [Convenience is Not an -ility](#convenience-is-not-an--ility)
    - [Deploy Early and Often](#deploy-early-and-often)
    - [Distinguish Business Exceptions from Technical](#distinguish-business-exceptions-from-technical)
    - [Do Lots of Deliberate Practice](#do-lots-of-deliberate-practice)
    - [Domain-Specific Languages](#domain-specific-languages)
    - [Don't Be Afraid to Break Things](#dont-be-afraid-to-break-things)
    - [Don't Be Cute with Your Test Data](#dont-be-cute-with-your-test-data)
    - [Don't Ignore That Error](#dont-ignore-that-error)
    - [Don't Just Learn the Language, Understand Its Culture](#dont-just-learn-the-language-understand-its-culture)
    - [Don't Nail Your Program into the Upright Position](#dont-nail-your-program-into-the-upright-position)
    - [Don't Rely on "Magic Happens Here"](#dont-rely-on-magic-happens-here)
    - [Don't Repeat Yourself](#dont-repeat-yourself)
      - [Duplication is Waste](#duplication-is-waste)
      - [Repetition in Process Calls for Automation](#repetition-in-process-calls-for-automation)
      - [Repetition in Logic Calls for Abstraction](#repetition-in-logic-calls-for-abstraction)
      - [A Matter of Principle](#a-matter-of-principle)
    - [Don't Touch That Code](#dont-touch-that-code)
    - [Encapsulate Behaviour, Not Just State](#encapsulate-behaviour-not-just-state)
    - [Floating-Point Numbers Aren't Real](#floating-point-numbers-arent-real)
    - [Fulfil Your Ambitions with Open Source](#fulfil-your-ambitions-with-open-source)
    - [Hard Work Does Not Pay Off](#hard-work-does-not-pay-off)
    - [How to Use a Bug Tracker](#how-to-use-a-bug-tracker)
    - [Improve Code by Removing It](#improve-code-by-removing-it)
    - [Interprocess Communication Affects Application Response Time](#interprocess-communication-affects-application-response-time)
    - [Keep the Build Clean](#keep-the-build-clean)
    - [Know How to Use Command-Line Tools](#know-how-to-use-command-line-tools)
    - [Know Well More Than Two Programming Languages](#know-well-more-than-two-programming-languages)
    - [Know Your IDE](#know-your-ide)
    - [Know Your Limits](#know-your-limits)
    - [Know Your Next Commit](#know-your-next-commit)
    - [Large, Interconnected Data Belongs to a Database](#large-interconnected-data-belongs-to-a-database)
    - [Learn Foreign Languages](#learn-foreign-languages)
    - [Learn to Estimate](#learn-to-estimate)
    - [Learn to Say, "Hello, World"](#learn-to-say-hello-world)
    - [Let Your Project to Speak for Itself](#let-your-project-to-speak-for-itself)
    - [Make Interfaces Easy to Use Correct and Hard to Use Incorrectly](#make-interfaces-easy-to-use-correct-and-hard-to-use-incorrectly)
    - [Make the Invisible More Visible](#make-the-invisible-more-visible)
    - [Message Passing Leads to Better Scalability in Parallel Systems](#message-passing-leads-to-better-scalability-in-parallel-systems)
    - [Missing Opportunities for Polymorphism](#missing-opportunities-for-polymorphism)
    - [News of the Weird: Testers Are Your Friends](#news-of-the-weird-testers-are-your-friends)
    - [One Binary](#one-binary)
    - [Only the Code Tells the Truth](#only-the-code-tells-the-truth)
    - [Own (and Refactor) the Build](#own-and-refactor-the-build)
    - [Pair Program and Feel the Flow](#pair-program-and-feel-the-flow)
    - [Prefer Domain-Specific Types to Primitive Types](#prefer-domain-specific-types-to-primitive-types)
    - [Prevent Errors](#prevent-errors)
    - [Put Everything Under Version Control](#put-everything-under-version-control)
    - [Put the Mouse Down and Step Away from the Keyboard](#put-the-mouse-down-and-step-away-from-the-keyboard)
    - [Read Code](#read-code)
    - [Read the Humanities](#read-the-humanities)
    - [Reinvent the Wheel Often](#reinvent-the-wheel-often)
    - [Resist the Temptation of the Singleton Pattern](#resist-the-temptation-of-the-singleton-pattern)
    - [Simplicity Comes from Reduction](#simplicity-comes-from-reduction)
    - [Start from Yes](#start-from-yes)
    - [Step Back and Automate, Automate, Automate](#step-back-and-automate-automate-automate)
    - [Take Advantage of Code Analysis Tools](#take-advantage-of-code-analysis-tools)
    - [Test for Required Behaviour, Not Incidental Behaviour](#test-for-required-behaviour-not-incidental-behaviour)
    - [Test Precisely and Concretely](#test-precisely-and-concretely)
    - [Test While You Sleep (And Over Weekends)](#test-while-you-sleep-and-over-weekends)
    - [Testing is the Engineering Rigour of Software Development](#testing-is-the-engineering-rigour-of-software-development)
    - [The Boy Scout Rule](#the-boy-scout-rule)
    - [The Golden Rule of API Design](#the-golden-rule-of-api-design)
    - [The Guru Myth](#the-guru-myth)
    - [The Linker Is Not a Magical Program](#the-linker-is-not-a-magical-program)
    - [The Longevity of Interim Solutions](#the-longevity-of-interim-solutions)
    - [The Professional Programmer](#the-professional-programmer)
    - [The Road to Performance is Littered with Dirty Code Bombs](#the-road-to-performance-is-littered-with-dirty-code-bombs)
    - [The Single Responsibility Principle](#the-single-responsibility-principle)
    - [The Unix Tools Are Your Friends](#the-unix-tools-are-your-friends)
    - [Thinking in States](#thinking-in-states)
    - [Two Heads Are Often Better Than One](#two-heads-are-often-better-than-one)
    - [Two Wrongs Can Make a Right (And Are Difficult to Fix)](#two-wrongs-can-make-a-right-and-are-difficult-to-fix)
    - [Ubuntu Coding for Your Friends](#ubuntu-coding-for-your-friends)
    - [Use the Right Algorithm and Data Structure](#use-the-right-algorithm-and-data-structure)
    - [Verbose Logging Will Disturb Your Sleep](#verbose-logging-will-disturb-your-sleep)
    - [WET Dilutes Performance Bottlenecks](#wet-dilutes-performance-bottlenecks)
    - [When Programmers and Testers Collaborate](#when-programmers-and-testers-collaborate)
    - [Write Code As If You Had to Support It for the Rest of Your Life](#write-code-as-if-you-had-to-support-it-for-the-rest-of-your-life)
    - [Write Small Functions Using Examples](#write-small-functions-using-examples)
    - [Write Tests for People](#write-tests-for-people)
    - [You Gotta Care About the Code](#you-gotta-care-about-the-code)
    - [Your Customers Do Not Mean What They Say](#your-customers-do-not-mean-what-they-say)
  - [*bash* Cookbook](#bash-cookbook)
    - [Preface](#preface)
      - [Who Should Read This Book](#who-should-read-this-book)
      - [About This Book](#about-this-book)
        - [GNU Software](#gnu-software)
        - [A Note About Code Examples](#a-note-about-code-examples)
        - [Useless Use of cat](#useless-use-of-cat)
        - [A Note About Perl](#a-note-about-perl)
    - [Beginning *bash*](#beginning-bash)
      - [Why *bash*?](#why-bash)
      - [The *bash* Shell](#the-bash-shell)
      - [Showing Where You Are](#showing-where-you-are)
      - [Finding \& Running Commands](#finding--running-commands)
      - [Getting Information About Files](#getting-information-about-files)
      - [Using Shell Quoting](#using-shell-quoting)
      - [Determining if You Are Running Interactively](#determining-if-you-are-running-interactively)
    - [Standard Output](#standard-output)
      - [Writing Output to the Terminal/Window](#writing-output-to-the-terminalwindow)
      - [Writing Output but Preserving Space](#writing-output-but-preserving-space)
      - [Writing Output with More Formatting Control](#writing-output-with-more-formatting-control)
      - [Writing Output Without the Newline](#writing-output-without-the-newline)
      - [Appending Rather than Clobbering Output](#appending-rather-than-clobbering-output)
      - [Using Just the Beginning of End of a File](#using-just-the-beginning-of-end-of-a-file)
      - [Throwing Output Away](#throwing-output-away)
      - [Saving or Grouping Output from Several Commands](#saving-or-grouping-output-from-several-commands)
      - [Connecting Two Programs by Using Output as Input](#connecting-two-programs-by-using-output-as-input)
      - [Saving a Copy of Output Even While Using It as Input](#saving-a-copy-of-output-even-while-using-it-as-input)
      - [Keeping Files Safe from Accidental Overwriting](#keeping-files-safe-from-accidental-overwriting)
      - [Clobbering a File on Purpose](#clobbering-a-file-on-purpose)
    - [Standard Input](#standard-input)
      - [Getting Input from File](#getting-input-from-file)
      - [Keeping Your Data with Your Script](#keeping-your-data-with-your-script)
      - [Preventing Weird Behaviour in a Here-Document](#preventing-weird-behaviour-in-a-here-document)
      - [Indenting Here-Documents](#indenting-here-documents)
      - [Getting User Input](#getting-user-input)
      - [Getting a Yes or No Input](#getting-a-yes-or-no-input)
      - [Selecting from a List of Options](#selecting-from-a-list-of-options)
      - [Prompting for a Password](#prompting-for-a-password)
    - [Executing Commands](#executing-commands)
      - [Running Any Executable](#running-any-executable)
      - [Running Several Commands in Sequence](#running-several-commands-in-sequence)
      - [Running Several Commands All at Once](#running-several-commands-all-at-once)
      - [Telling Whether a Command Succeeded or Not](#telling-whether-a-command-succeeded-or-not)
      - [Running a Command Only if Another Command Succeeded](#running-a-command-only-if-another-command-succeeded)
      - [Using Fewer if Statements](#using-fewer-if-statements)
      - [Running Long Jobs Unattended](#running-long-jobs-unattended)
      - [Displaying Error Messages When Failures Occur](#displaying-error-messages-when-failures-occur)
      - [Running Commands from a Variable](#running-commands-from-a-variable)
      - [Running All Scripts in a Directory](#running-all-scripts-in-a-directory)
    - [Basic Scripting: Shell Variables](#basic-scripting-shell-variables)
      - [Embedding Documentation in Shell Scripts](#embedding-documentation-in-shell-scripts)
      - [Promoting Script Readability](#promoting-script-readability)
      - [Separating Variable Names from Surrounding Text](#separating-variable-names-from-surrounding-text)
      - [Exporting Variables](#exporting-variables)
      - [Seeing All Variable Values](#seeing-all-variable-values)
      - [Using Parameters in a Shell Script](#using-parameters-in-a-shell-script)
      - [Looping Over Arguments Passed to a Script](#looping-over-arguments-passed-to-a-script)
      - [Handling Parameters with Spaces](#handling-parameters-with-spaces)
      - [Handling Lists of Parameters with Spaces](#handling-lists-of-parameters-with-spaces)
      - [Counting Arguments](#counting-arguments)
      - [Consuming Arguments](#consuming-arguments)
      - [Getting Default Values](#getting-default-values)
      - [Setting Default Values](#setting-default-values)
      - [Using *null* as Valid Default Value](#using-null-as-valid-default-value)
      - [Using More than Just a Constant String for Default](#using-more-than-just-a-constant-string-for-default)
      - [Giving an Error Message for Unset Parameters](#giving-an-error-message-for-unset-parameters)
      - [Changing Pieces of a String](#changing-pieces-of-a-string)
      - [Getting the Absolute Value of a Number](#getting-the-absolute-value-of-a-number)
      - [Using *bash* for *basename*](#using-bash-for-basename)
      - [Using *bash* for *dirname*](#using-bash-for-dirname)
      - [Using Alternate Values for Comma-Separated Values](#using-alternate-values-for-comma-separated-values)
      - [Using Array Variables](#using-array-variables)
      - [Converting Between Upper- and Lowercase](#converting-between-upper--and-lowercase)
      - [Converting to Camel Case](#converting-to-camel-case)
    - [Shell Logic \& Arithmetic](#shell-logic--arithmetic)
      - [Doing Arithmetic in Your Shell Script](#doing-arithmetic-in-your-shell-script)
      - [Branching on Conditions](#branching-on-conditions)
      - [Testing for File Characteristics](#testing-for-file-characteristics)
      - [Testing for More than One Thing](#testing-for-more-than-one-thing)
      - [Testing for String Characteristics](#testing-for-string-characteristics)
      - [Testing for Equality](#testing-for-equality)
      - [Testing with Pattern Matches](#testing-with-pattern-matches)
      - [Testing with Regular Expressions](#testing-with-regular-expressions)
      - [Changing Behaviour with Redirections](#changing-behaviour-with-redirections)
      - [Looping for a While](#looping-for-a-while)
      - [Looping with a *read*](#looping-with-a-read)
      - [Looping with a Count](#looping-with-a-count)
      - [Looping with Floating-Point Values](#looping-with-floating-point-values)
      - [Branching Many Ways](#branching-many-ways)
      - [Parsing Command-Line Arguments](#parsing-command-line-arguments)
      - [Creating Simple Menus](#creating-simple-menus)
      - [Changing the Prompt on Simple Menus](#changing-the-prompt-on-simple-menus)
      - [Creating a Simple RPN Calculator](#creating-a-simple-rpn-calculator)
      - [Creating a Command-Line Calculator](#creating-a-command-line-calculator)
    - [Intermediate Shell Tools I](#intermediate-shell-tools-i)
      - [Sifting Through Files for a String](#sifting-through-files-for-a-string)
      - [Getting Just the Filename from a Search](#getting-just-the-filename-from-a-search)
      - [Getting a Simple True/False from a Search](#getting-a-simple-truefalse-from-a-search)
      - [Searching for Text While Ignoring Case](#searching-for-text-while-ignoring-case)
      - [Doing a Search in a Pipeline](#doing-a-search-in-a-pipeline)
      - [Paring Down What the Search Finds](#paring-down-what-the-search-finds)
      - [Searching with More Complex Patterns](#searching-with-more-complex-patterns)
      - [Searching for an SSN](#searching-for-an-ssn)
      - [Grepping Compressed Files](#grepping-compressed-files)
      - [Keeping Some Output, Discarding the Rest](#keeping-some-output-discarding-the-rest)
      - [Keeping Only a Portion of a Line of Output](#keeping-only-a-portion-of-a-line-of-output)
      - [Reversing the Words on Each Line](#reversing-the-words-on-each-line)
      - [Summing a List of Numbers](#summing-a-list-of-numbers)
      - [Counting String Values with *awk*](#counting-string-values-with-awk)
      - [Counting String Values with *bash*](#counting-string-values-with-bash)
      - [Showing Data as a Quick and Easy Histogram](#showing-data-as-a-quick-and-easy-histogram)
      - [An Easy Histogram with *bash*](#an-easy-histogram-with-bash)
      - [Showing a Paragraph of Text After a Found Phrase](#showing-a-paragraph-of-text-after-a-found-phrase)
    - [Intermediate Shell Tools II](#intermediate-shell-tools-ii)
      - [Sorting Your Output](#sorting-your-output)
      - [Sorting Numbers](#sorting-numbers)
      - [Sorting IP Addresses](#sorting-ip-addresses)
      - [Cutting Out Parts of Your Output](#cutting-out-parts-of-your-output)
      - [Removing Duplicate Lines](#removing-duplicate-lines)
      - [Compressing Files](#compressing-files)
      - [Uncompressing Files](#uncompressing-files)
      - [Checking a *tar* Archive for Unique Directories](#checking-a-tar-archive-for-unique-directories)
      - [Translating Characters](#translating-characters)
      - [Converting Uppercase to Lowercase](#converting-uppercase-to-lowercase)
      - [Converting DOS Files to Linux Format](#converting-dos-files-to-linux-format)
      - [Removing Smart Quotes](#removing-smart-quotes)
      - [Counting Lines, Words, or Characters in a File](#counting-lines-words-or-characters-in-a-file)
      - [Rewrapping Paragraphs](#rewrapping-paragraphs)
      - [Doing More with *less*](#doing-more-with-less)
    - [Finding Files: *find*, *locate*, *slocate*](#finding-files-find-locate-slocate)
      - [Finding All Your MP3 Files](#finding-all-your-mp3-files)
      - [Handling Filenames Containing Odd Characters](#handling-filenames-containing-odd-characters)
      - [Speeding Up Operations on Found Files](#speeding-up-operations-on-found-files)
      - [Finding Files Across Symbolic Links](#finding-files-across-symbolic-links)
      - [Finding Files Irrespective of Case](#finding-files-irrespective-of-case)
      - [Finding Files by Date](#finding-files-by-date)
      - [Finding Files by Type](#finding-files-by-type)
      - [Finding File by Size](#finding-file-by-size)
      - [Finding Files by Content](#finding-files-by-content)
      - [Finding Existing Files \& Content Fast](#finding-existing-files--content-fast)
      - [Finding a File Using a List of Possible Locations](#finding-a-file-using-a-list-of-possible-locations)
    - [Additional Features for Scripting](#additional-features-for-scripting)
      - ["Daemon-ising" Your Script](#daemon-ising-your-script)
      - [Reusing Code with Includes \& Sourcing](#reusing-code-with-includes--sourcing)
      - [Using Configuration Files in a Script](#using-configuration-files-in-a-script)
      - [Defining Functions](#defining-functions)
      - [Using Functions: Parameters \& Return Values](#using-functions-parameters--return-values)
      - [Trapping Interrupts](#trapping-interrupts)
      - [Redefining Commands with *alias*](#redefining-commands-with-alias)
      - [Avoiding Aliases \& Functions](#avoiding-aliases--functions)
      - [Counted Elapsed Time](#counted-elapsed-time)
      - [Writing Wrappers](#writing-wrappers)
    - [Working with Dates \& Times](#working-with-dates--times)
      - [Formatting Dates for Display](#formatting-dates-for-display)
      - [Supplying a Default Date](#supplying-a-default-date)
      - [Automating Date Ranges](#automating-date-ranges)
      - [Converting Dates \& Times to Epoch Seconds](#converting-dates--times-to-epoch-seconds)
      - [Converting Epoch Seconds to Dates \& Times](#converting-epoch-seconds-to-dates--times)
      - [Getting Yesterday or Tomorrow with Perl](#getting-yesterday-or-tomorrow-with-perl)
      - [Figuring Out Date \& Time Arithmetic](#figuring-out-date--time-arithmetic)
      - [Handling Time Zones, Daylight Saving Time, \& Leap Years](#handling-time-zones-daylight-saving-time--leap-years)
      - [Using *date* \& *cron* to Run a Script on the Nth Day](#using-date--cron-to-run-a-script-on-the-nth-day)
      - [Logging with Dates](#logging-with-dates)
    - [End-User Tasks as Shell Scripts](#end-user-tasks-as-shell-scripts)
      - [Starting Simple by Printing Dashes](#starting-simple-by-printing-dashes)
      - [Viewing Photos in an Album](#viewing-photos-in-an-album)
      - [Loading Your MP3 Player](#loading-your-mp3-player)
      - [Burning a CD](#burning-a-cd)
      - [Comparing Two Documents](#comparing-two-documents)
    - [Parsing \& Similar Tasks](#parsing--similar-tasks)
      - [Parsing Arguments for Your Shell Script](#parsing-arguments-for-your-shell-script)
      - [Parsing Arguments with Your Own Error Messages](#parsing-arguments-with-your-own-error-messages)
      - [Parsing Some HTML](#parsing-some-html)
      - [Parsing Output into an Array](#parsing-output-into-an-array)
      - [Parsing Output with a Function Call](#parsing-output-with-a-function-call)
      - [Parsing Text with a *read* Statement](#parsing-text-with-a-read-statement)
      - [Parsing with *read* into an Array](#parsing-with-read-into-an-array)
      - [Reading an Entire File](#reading-an-entire-file)
      - [Getting Your Plurals Right](#getting-your-plurals-right)
      - [Taking It One Character at a Time](#taking-it-one-character-at-a-time)
      - [Cleaning Up an SVN Source Tree](#cleaning-up-an-svn-source-tree)
      - [Setting Up a Database with MySQL](#setting-up-a-database-with-mysql)
      - [Isolating Specific Fields in Data](#isolating-specific-fields-in-data)
      - [Updating Specific Fields in Datafiles](#updating-specific-fields-in-datafiles)
      - [Trimming Whitespace](#trimming-whitespace)
      - [Compressing Whitespace](#compressing-whitespace)
      - [Processing Fixed-Length Records](#processing-fixed-length-records)
      - [Processing Files with No Line Breaks](#processing-files-with-no-line-breaks)
      - [Converting a Datafile to CSV](#converting-a-datafile-to-csv)
      - [Parsing a CSV Datafile](#parsing-a-csv-datafile)
    - [Writing Secure Shell Scripts](#writing-secure-shell-scripts)
      - [Avoiding Common Security Problems](#avoiding-common-security-problems)
      - [Avoiding Interpreter Spoofing](#avoiding-interpreter-spoofing)
      - [Setting a Secure *$PATH*](#setting-a-secure-path)
      - [Clearing All Aliases](#clearing-all-aliases)
      - [Clearing the Command Hash](#clearing-the-command-hash)
      - [Preventing Core Dumps](#preventing-core-dumps)
      - [Setting a Secure *$IFS*](#setting-a-secure-ifs)
      - [Setting a Secure *umask*](#setting-a-secure-umask)
      - [Finding World-Writeable Directories in Your *$PATH*](#finding-world-writeable-directories-in-your-path)
      - [Adding the Current Directory to the *$PATH*](#adding-the-current-directory-to-the-path)
      - [Using Secure Temporary Files](#using-secure-temporary-files)
      - [Validating Input](#validating-input)
      - [Setting Permissions](#setting-permissions)
      - [Leaking Passwords into the Process List](#leaking-passwords-into-the-process-list)
      - [Writing *setuid* or *setgid* Scripts](#writing-setuid-or-setgid-scripts)
      - [Restricting Guest Users](#restricting-guest-users)
      - [Using *chroot* Jails](#using-chroot-jails)
      - [Running as Non-root User](#running-as-non-root-user)
      - [Using *sudo* More Securely](#using-sudo-more-securely)
      - [Using Passwords in Scripts](#using-passwords-in-scripts)
      - [Using SSH Without a Password](#using-ssh-without-a-password)
      - [Restricting SSH Commands](#restricting-ssh-commands)
      - [Disconnecting Inactive Sessions](#disconnecting-inactive-sessions)
    - [Advanced Scripting](#advanced-scripting)
      - [Finding *bash* Portable for *#!*](#finding-bash-portable-for-)
      - [Setting a POSIX *$PATH*](#setting-a-posix-path)
      - [Developing Portable Shell Scripts](#developing-portable-shell-scripts)
      - [Testing Scripts Using Virtual machines](#testing-scripts-using-virtual-machines)
      - [Using *for* Loops Portably](#using-for-loops-portably)
      - [Using *echo* Portably](#using-echo-portably)
      - [Splitting Output Only When Necessary](#splitting-output-only-when-necessary)
      - [Viewing Output in Hex](#viewing-output-in-hex)
      - [Using *bash* Net-Redirection](#using-bash-net-redirection)
      - [Finding My IP Address](#finding-my-ip-address)
      - [Getting Input from Another Machine](#getting-input-from-another-machine)
      - [Redirecting Output for the Life of a Script](#redirecting-output-for-the-life-of-a-script)
      - [Working Around *"Argument list too long"* Errors](#working-around-argument-list-too-long-errors)
      - [Logging to *syslog* from Your Script](#logging-to-syslog-from-your-script)
      - [Using *logger* Correctly](#using-logger-correctly)
      - [Sending Email from Your Script](#sending-email-from-your-script)
      - [Automating a Process Using Phases](#automating-a-process-using-phases)
      - [Doing Two Things at Once](#doing-two-things-at-once)
      - [Running an SSH Command on Multiple Hosts](#running-an-ssh-command-on-multiple-hosts)
    - [Configuring \& Customising *bash*](#configuring--customising-bash)
      - [*bash* Startup Options](#bash-startup-options)
      - [Customising Your Prompt](#customising-your-prompt)
      - [A Prompt Before Your Program Runs](#a-prompt-before-your-program-runs)
      - [Changing Your *$PATH* Permanently](#changing-your-path-permanently)
      - [Changing Your *$PATH* Temporarily](#changing-your-path-temporarily)
      - [Setting Your *$CDPATH*](#setting-your-cdpath)
      - [When Programs Are Not Found](#when-programs-are-not-found)
      - [Shorting or Changing Command Names](#shorting-or-changing-command-names)
      - [Adjusting Shell Behaviour \& Environment](#adjusting-shell-behaviour--environment)
      - [Adjusting *readline* Behaviour Using *.inputrc*](#adjusting-readline-behaviour-using-inputrc)
      - [Keeping a Private Stash of Utility by Adding *~/bin*](#keeping-a-private-stash-of-utility-by-adding-bin)
      - [Using Secondary Prompts: *$PS2*, *$PS3*, *$PS4*](#using-secondary-prompts-ps2-ps3-ps4)
      - [Synchronising Shell History Between Sessions](#synchronising-shell-history-between-sessions)
      - [Setting Shell History Options](#setting-shell-history-options)
      - [Creating a Better *cd* Command](#creating-a-better-cd-command)
      - [Creating \& Changing Into a New Directory in One Step](#creating--changing-into-a-new-directory-in-one-step)
      - [Getting to the Bottom of Things](#getting-to-the-bottom-of-things)
      - [Adding New Features to *bash* Using Loadable Builtins](#adding-new-features-to-bash-using-loadable-builtins)
      - [Improving Programmable Completion](#improving-programmable-completion)
      - [Using Initialisation Files Correctly](#using-initialisation-files-correctly)
      - [Creating Self-Contained, Portable *rc* Files](#creating-self-contained-portable-rc-files)
      - [Getting Start with a Custom Configuration](#getting-start-with-a-custom-configuration)
    - [Housekeeping \& Administrative Tasks](#housekeeping--administrative-tasks)
      - [Renaming Many Files](#renaming-many-files)
      - [Using GNU Texinfo \& *info* on Linux](#using-gnu-texinfo--info-on-linux)
      - [Unzipping Many ZIP Files](#unzipping-many-zip-files)
      - [Recovering Disconnected Sessions Using *screen*](#recovering-disconnected-sessions-using-screen)
      - [Sharing a Single *bash* Session](#sharing-a-single-bash-session)
      - [Logging an Entire Session or Batch Job](#logging-an-entire-session-or-batch-job)
      - [Clearing the Screen When You Log Out](#clearing-the-screen-when-you-log-out)
      - [Capturing File Metadata for Recovery](#capturing-file-metadata-for-recovery)
      - [Creating an Index of Many Files](#creating-an-index-of-many-files)
      - [Using *diff* \& *patch*](#using-diff--patch)
      - [Counting Differences in Files](#counting-differences-in-files)
      - [Removing or Renaming Files Named with Special Characters](#removing-or-renaming-files-named-with-special-characters)
      - [Prepending Data to a File](#prepending-data-to-a-file)
      - [Editing a File in Place](#editing-a-file-in-place)
      - [Using *sudo* on a Group of Commands](#using-sudo-on-a-group-of-commands)
      - [Finding Lines That Appear in One File but Not in Another](#finding-lines-that-appear-in-one-file-but-not-in-another)
      - [Keeping the Most Recent N Objects](#keeping-the-most-recent-n-objects)
      - [Writing to a Circular Log](#writing-to-a-circular-log)
      - [Circular Backups](#circular-backups)
      - [Grepping *ps* Output Without Also Getting the *grep* Process Itself](#grepping-ps-output-without-also-getting-the-grep-process-itself)
      - [Finding Out Whether a Process Is Running](#finding-out-whether-a-process-is-running)
      - [Adding a Prefix or Suffix to Output](#adding-a-prefix-or-suffix-to-output)
      - [Numbering Lines](#numbering-lines)
      - [Writing Sequences](#writing-sequences)
      - [Emulating the DOS Pause Command](#emulating-the-dos-pause-command)
      - [Commodifying Numbers](#commodifying-numbers)
    - [Working Faster by Typing Less](#working-faster-by-typing-less)
      - [Moving Quickly Among Arbitrary Directories](#moving-quickly-among-arbitrary-directories)
      - [Repeating the Last Command](#repeating-the-last-command)
      - [Quick Substitution](#quick-substitution)
      - [Reusing Arguments](#reusing-arguments)
      - [Finishing Names for You](#finishing-names-for-you)
      - [Playing It Safe](#playing-it-safe)
      - [Big Changes, More Lines](#big-changes-more-lines)
    - [Tips \& Traps: Common Goofs for Notices](#tips--traps-common-goofs-for-notices)
      - [Forgetting to Set Execute Permissions](#forgetting-to-set-execute-permissions)
      - [Fixing *"No such file or directory"* Errors](#fixing-no-such-file-or-directory-errors)
      - [Forgetting That the Current Directory Is Not in the *$PATH*](#forgetting-that-the-current-directory-is-not-in-the-path)
      - [Naming Your Script *"test"*](#naming-your-script-test)
      - [Expecting to Change Exported Variables](#expecting-to-change-exported-variables)
      - [Forgetting Quotes Leads to *"command not found"* on Assignments](#forgetting-quotes-leads-to-command-not-found-on-assignments)
      - [Forgetting that Pattern Matching Alphabetises](#forgetting-that-pattern-matching-alphabetises)
      - [Forgetting that Pipelines Make Subshells](#forgetting-that-pipelines-make-subshells)
      - [Making Your Terminal Sane Again](#making-your-terminal-sane-again)
      - [Deleting Files Using an Empty Variable](#deleting-files-using-an-empty-variable)
      - [Seeing Odd Behaviour from *printf*](#seeing-odd-behaviour-from-printf)
      - [Testing *bash* Script Syntax](#testing-bash-script-syntax)
      - [Debugging Scripts](#debugging-scripts)
      - [Avoid *"command not found"* When Using Functions](#avoid-command-not-found-when-using-functions)
      - [Confusing Shell Wildcards \& Regular Expressions](#confusing-shell-wildcards--regular-expressions)
  - [The Pragmatic Programmer](#the-pragmatic-programmer)
    - [Preface to the Second Edition](#preface-to-the-second-edition)
      - [How the Book is Organised](#how-the-book-is-organised)
      - [What's In a Name?](#whats-in-a-name)
    - [From the Preface to the First Edition](#from-the-preface-to-the-first-edition)
      - [Who Should Read This Book?](#who-should-read-this-book-1)
      - [What Makes a Pragmatic Programmer?](#what-makes-a-pragmatic-programmer)
        - [Tip 1: Care About Your Craft](#tip-1-care-about-your-craft)
        - [Tip 2: Think! About Your Work](#tip-2-think-about-your-work)
      - [Individual Pragmatists, Large Teams](#individual-pragmatists-large-teams)
      - [It's a Continuous Process](#its-a-continuous-process)
    - [A Pragmatic Philosophy](#a-pragmatic-philosophy)
      - [It's Your Life](#its-your-life)
        - [Tip 3: You Have Agency](#tip-3-you-have-agency)
      - [The Cat Ate My Source Code](#the-cat-ate-my-source-code)
        - [Team Trust](#team-trust)
        - [Take Responsibility](#take-responsibility)
        - [Tip 4: Provide Options, Don't Make Lame Excuses](#tip-4-provide-options-dont-make-lame-excuses)
        - [Challenges (Take Responsibility)](#challenges-take-responsibility)
      - [Software Entropy](#software-entropy)
        - [Tip 5: Don't Live with Broken Windows](#tip-5-dont-live-with-broken-windows)
        - [First, Do No Harm](#first-do-no-harm)
        - [Challenges (Software Entropy)](#challenges-software-entropy)
      - [Stone Soup \& Boiled Frogs](#stone-soup--boiled-frogs)
        - [Tip 6 Be a Catalyst for Change](#tip-6-be-a-catalyst-for-change)
      - [The Villager's Side](#the-villagers-side)
        - [Tip 7: Remember the Big Picture](#tip-7-remember-the-big-picture)
        - [Challenges (The Villager's Side)](#challenges-the-villagers-side)
      - [Good Enough Software](#good-enough-software)
        - [Involve Your Users in the Trade Off](#involve-your-users-in-the-trade-off)
        - [Tip 8: Make Quality a Requirements Issue](#tip-8-make-quality-a-requirements-issue)
        - [Know When to Stop](#know-when-to-stop)
        - [Challenges (Good Enough Software)](#challenges-good-enough-software)
      - [Your Knowledge Portfolio](#your-knowledge-portfolio)
        - [Building Your Portfolio](#building-your-portfolio)
        - [Tip 9: Invest Regularly in Your Knowledge Portfolio](#tip-9-invest-regularly-in-your-knowledge-portfolio)
        - [Opportunities for Learning](#opportunities-for-learning)
        - [Critical Thinking](#critical-thinking)
        - [Tip 10: Critically Analyse What You Read \& Hear](#tip-10-critically-analyse-what-you-read--hear)
        - [Challenges (Your Knowledge Portfolio)](#challenges-your-knowledge-portfolio)
      - [Communicate](#communicate)
        - [Tip 11: English is Just Another Language](#tip-11-english-is-just-another-language)
        - [Know Your Audience](#know-your-audience)
        - [Know What You Want to Say](#know-what-you-want-to-say)
        - [Choose Your Moment](#choose-your-moment)
        - [Choose a Style](#choose-a-style)
        - [Make it Look Good](#make-it-look-good)
        - [Involve Your Audience](#involve-your-audience)
        - [Be a Listener](#be-a-listener)
        - [Get Back to People](#get-back-to-people)
        - [Tip 12: It's Both What You Say and the Way You Say It](#tip-12-its-both-what-you-say-and-the-way-you-say-it)
        - [Communication Through Documentation](#communication-through-documentation)
        - [Tip 13: Build Documentation In, Don't Bolt It On](#tip-13-build-documentation-in-dont-bolt-it-on)
        - [Challenges (Communicate)](#challenges-communicate)
    - [A Pragmatic Approach](#a-pragmatic-approach)
      - [The Essence of Good Design](#the-essence-of-good-design)
        - [Tip 14: Good Design is Easier to Change Than Bad Design](#tip-14-good-design-is-easier-to-change-than-bad-design)
        - [ETC is a Value, Not a Rule](#etc-is-a-value-not-a-rule)
        - [Challenges (The Essence of Good Design)](#challenges-the-essence-of-good-design)
      - [DRY - The Evils of Duplication](#dry---the-evils-of-duplication)
        - [Tip 15: DRY - Don't Repeat Yourself](#tip-15-dry---dont-repeat-yourself)
        - [DRY is More Than Code](#dry-is-more-than-code)
        - [Duplication in Code](#duplication-in-code)
          - [Not All Code Duplication is Knowledge Duplication](#not-all-code-duplication-is-knowledge-duplication)
        - [Duplication in Documentation](#duplication-in-documentation)
          - [DRY Violations in Data](#dry-violations-in-data)
        - [Representational Duplication](#representational-duplication)
          - [Duplication Across Internal APIs](#duplication-across-internal-apis)
          - [Duplication Across External APIs](#duplication-across-external-apis)
          - [Duplication within Data Sources](#duplication-within-data-sources)
        - [Interdeveloper Duplication](#interdeveloper-duplication)
        - [Tip 16: Make It Easy to Rescue](#tip-16-make-it-easy-to-rescue)
      - [Orthogonality](#orthogonality)
        - [What is Orthogonality?](#what-is-orthogonality)
        - [Benefits of Orthogonality](#benefits-of-orthogonality)
        - [Tip 17: Eliminate Effects Between Things](#tip-17-eliminate-effects-between-things)
          - [Gain Productivity](#gain-productivity)
          - [Reduce Risk](#reduce-risk)
        - [Design](#design)
        - [Toolkits \& Libraries](#toolkits--libraries)
        - [Coding](#coding)
        - [Testing](#testing)
        - [Orthogonality Through Documentation](#orthogonality-through-documentation)
        - [Living with Orthogonality](#living-with-orthogonality)
          - [Challenges (Living with Orthogonality)](#challenges-living-with-orthogonality)
          - [Exercises (Living with Orthogonality)](#exercises-living-with-orthogonality)
          - [Exercise 1](#exercise-1)
      - [Reversibility](#reversibility)
        - [Tip 18: There Are No Final Decisions](#tip-18-there-are-no-final-decisions)
        - [Tip 19: Forego Following Fads](#tip-19-forego-following-fads)
        - [Challenges (Reversibility)](#challenges-reversibility)
      - [Tracer Bullets](#tracer-bullets)
      - [Prototypes \& Post-It Notes](#prototypes--post-it-notes)
      - [Domain Languages](#domain-languages)
      - [Estimating](#estimating)
    - [The Basic Tools](#the-basic-tools)
      - [The Power of Plain Text](#the-power-of-plain-text)
      - [Shell Games](#shell-games)
      - [Power Editing](#power-editing)
      - [Version Control](#version-control)
      - [Debugging](#debugging)
      - [Text Manipulation](#text-manipulation)
      - [Engineering Daybooks](#engineering-daybooks)
    - [Pragmatic Paranoia](#pragmatic-paranoia)
      - [Design by Contract](#design-by-contract)
      - [Dead Programs Tell No Tales](#dead-programs-tell-no-tales)
      - [Assertive Programming](#assertive-programming)
      - [How to Balance Resources](#how-to-balance-resources)
      - [Don't Outrun Your Headlights](#dont-outrun-your-headlights)
    - [Bend, or Break](#bend-or-break)
      - [Decoupling](#decoupling)
      - [Juggling the Real World](#juggling-the-real-world)
      - [Transforming Programming](#transforming-programming)
      - [Inheritance Task](#inheritance-task)
      - [Configuration](#configuration)
    - [Concurrency](#concurrency)
      - [Breaking Temporal Coupling](#breaking-temporal-coupling)
      - [Shared State is Incorrect State](#shared-state-is-incorrect-state)
      - [Actors \& Processes](#actors--processes)
      - [Blackboards](#blackboards)
    - [While You Are Coding](#while-you-are-coding)
      - [Listen to Your Lizard Brain](#listen-to-your-lizard-brain)
      - [Programming by Coincidence](#programming-by-coincidence)
      - [Algorithm Speed](#algorithm-speed)
      - [Refactoring](#refactoring)
      - [Test to Code](#test-to-code)
      - [Property-Based Testing](#property-based-testing)
      - [Stay Safe Out There](#stay-safe-out-there)
      - [Naming Things](#naming-things)
    - [Before the Project](#before-the-project)
      - [The Requirements Pit](#the-requirements-pit)
      - [Solving Impossible Puzzles](#solving-impossible-puzzles)
      - [Working Together](#working-together)
      - [The Essence of Agility](#the-essence-of-agility)
    - [Pragmatic Projects](#pragmatic-projects)
      - [Pragmatic Teams](#pragmatic-teams)
      - [Coconuts Don't Cut It](#coconuts-dont-cut-it)
      - [Pragmatic Starter Kit](#pragmatic-starter-kit)
      - [Delight Your Users](#delight-your-users)
      - [Pride \& Prejudice](#pride--prejudice)
- [Online Notes](#online-notes)
  - [Databases](#databases)
    - [Database Management](#database-management)
      - [Sharding](#sharding)
        - [What is Database Sharding?](#what-is-database-sharding)
        - [Do You Need Database Sharding?](#do-you-need-database-sharding)
        - [Advantages of Sharding](#advantages-of-sharding)
        - [Disadvantages of Sharding](#disadvantages-of-sharding)
        - [How Does Sharding Work? These Questions Should Be Answered](#how-does-sharding-work-these-questions-should-be-answered)
        - [Sharding Architectures and Types](#sharding-architectures-and-types)
          - [Ranged/Dynamic Sharding](#rangeddynamic-sharding)
          - [Algorithmic/Hashed Sharding](#algorithmichashed-sharding)
          - [Entity-Based/Relationship-Based Sharding](#entity-basedrelationship-based-sharding)
          - [Geography-Based Sharding/Geosharding](#geography-based-shardinggeosharding)
        - [Sharding vs Partitioning](#sharding-vs-partitioning)
  - [Inter-Service Communication](#inter-service-communication)
    - [Security](#security)
      - [Service Mesh](#service-mesh)
        - [Service Mesh Overview](#service-mesh-overview)
        - [Scenarios for a service mesh](#scenarios-for-a-service-mesh)
        - [Selection Criteria for Installing a Service Mesh](#selection-criteria-for-installing-a-service-mesh)
      - [TLS](#tls)
        - [TLS Overview](#tls-overview)
        - [How TLS Works](#how-tls-works)
        - [SSL vs TLS](#ssl-vs-tls)
        - [How Does TLS Affect Web Application Performance?](#how-does-tls-affect-web-application-performance)
          - [TLS Handshake Protocol](#tls-handshake-protocol)
          - [Cipher Suites](#cipher-suites)
        - [Mitigating the Negative Effects of TLS on Web Application Performance](#mitigating-the-negative-effects-of-tls-on-web-application-performance)
  - [Telecommunications](#telecommunications)
    - [Network Slicing](#network-slicing)
      - [What is Network Slicing?](#what-is-network-slicing)
      - [Benefits of Network Slicing](#benefits-of-network-slicing)
      - [How 5G Network Slicing Works](#how-5g-network-slicing-works)
      - [Network Slicing Use Cases](#network-slicing-use-cases)
- [References](#references)
  - [Ericsson](#ericsson)
    - [Ericsson: Navigate the Network Slicing Transformation Journey](#ericsson-navigate-the-network-slicing-transformation-journey)
  - [Microsoft](#microsoft)
    - [Microsoft: About Service Meshes](#microsoft-about-service-meshes)
  - [Mongodb](#mongodb)
    - [Mongodb: Database Sharding](#mongodb-database-sharding)
  - [Nginx](#nginx)
    - [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)
  - [O'Reilly](#oreilly)
    - [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)
    - [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)
  - [Tech Target](#tech-target)
    - [Tech Target: Network Slicing](#tech-target-network-slicing)
  - [Techradar](#techradar)
    - [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)
  - [The Pragmatic Bookshelf](#the-pragmatic-bookshelf)
    - [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](#the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)
<!-- markdownlint-restore -->

# Book Notes

## 97 Things Every Programmer Should Know

- Bugs & Fixes

  - [Check Your Code First Before Looking to Blame Others](#check-your-code-first-before-looking-to-blame-others)

  - [Don't Touch That Code](#dont-touch-that-code)

  - [How to Use a Bug Tracker](#how-to-use-a-bug-tracker)

  - [Two Wrongs Can Make a Right (And Are Difficult to Fix)](#two-wrongs-can-make-a-right-and-are-difficult-to-fix)

- Build & Deployment:

  - [Deploy Early and Often](#deploy-early-and-often)

  - [Don't Touch That Code](#dont-touch-that-code)

  - [Keep the Build Clean](#keep-the-build-clean)

  - [Let Your Project to Speak for Itself](#let-your-project-to-speak-for-itself)

  - [One Binary](#one-binary)

  - [Own (and Refactor) the Build](#own-and-refactor-the-build)

- Coding Guidelines & Code Layout:

  - [A Comment on Comments](#a-comment-on-comments)

  - [Automate Your Coding Standard](#automate-your-coding-standard)

  - [Code Layout Matters](#code-layout-matters)

  - [Code Reviews](#code-reviews)

  - [Comment Only What the Code Cannot Say](#comment-only-what-the-code-cannot-say)

  - [Take Advantage of Code Analysis Tools](#take-advantage-of-code-analysis-tools)

- Design Principles & Coding Techniques

  - [Apply Functional Programming Principles](#apply-functional-programming-principles)

  - [Ask, "What Would the User Do?" (You Are Not the User)](#ask-what-would-the-user-do-you-are-not-the-user)

  - [Beauty Is in Simplicity](#beauty-is-in-simplicity)

  - [Choose Your Tools with Care](#choose-your-tools-with-care)

  - [Code in the Language of the Domain](#code-in-the-language-of-the-domain)

  - [Code is Design](#code-is-design)

  - [Coding with Reason](#coding-with-reason)

  - [Convenience is Not an -ility](#convenience-is-not-an--ility)

  - [Distinguish Business Exceptions from Technical](#distinguish-business-exceptions-from-technical)

  - [Don't Repeat Yourself](#dont-repeat-yourself)

  - [Encapsulate Behaviour, Not Just State](#encapsulate-behaviour-not-just-state)

  - [Interprocess Communication Affects Application Response Time](
    #interprocess-communication-affects-application-response-time)

  - [Make Interfaces Easy to Use Correct and Hard to Use Incorrectly](
    #make-interfaces-easy-to-use-correct-and-hard-to-use-incorrectly)

  - [Message Passing Leads to Better Scalability in Parallel Systems](
    #message-passing-leads-to-better-scalability-in-parallel-systems)

  - [Missing Opportunities for Polymorphism](#missing-opportunities-for-polymorphism)

  - [Only the Code Tells the Truth](#only-the-code-tells-the-truth)

  - [Prefer Domain-Specific Types to Primitive Types](#prefer-domain-specific-types-to-primitive-types)

  - [Prevent Errors](#prevent-errors)

  - [The Golden Rule of API Design](#the-golden-rule-of-api-design)

  - [The Single Responsibility Principle](#the-single-responsibility-principle)

  - [Thinking in States](#thinking-in-states)

  - [WET Dilutes Performance Bottlenecks](#wet-dilutes-performance-bottlenecks)

- Domain Thinking:

  - [Code in the Language of the Domain](#code-in-the-language-of-the-domain)

  - [Domain-Specific Languages](#domain-specific-languages)

  - [Learn Foreign Languages](#learn-foreign-languages)

  - [Prefer Domain-Specific Types to Primitive Types](#prefer-domain-specific-types-to-primitive-types)

  - [Read the Humanities](#read-the-humanities)

  - [Thinking in States](#thinking-in-states)

  - [Write Small Functions Using Examples](#write-small-functions-using-examples)

- Errors, Error Handling, & Exceptions

  - [Distinguish Business Exceptions from Technical](#distinguish-business-exceptions-from-technical)

  - [Don't Ignore That Error](#dont-ignore-that-error)

  - [Don't Nail Your Program into the Upright Position](#dont-nail-your-program-into-the-upright-position)

  - [Prevent Errors](#prevent-errors)

  - [Verbose Logging Will Disturb Your Sleep](#verbose-logging-will-disturb-your-sleep)

- Learning, Skills, & Expertise

  - [Continuous Learning](#continuous-learning)

  - [Do Lots of Deliberate Practice](#do-lots-of-deliberate-practice)

  - [Don't Just Learn the Language, Understand Its Culture](#dont-just-learn-the-language-understand-its-culture)

  - [Fulfil Your Ambitions with Open Source](#fulfil-your-ambitions-with-open-source)

  - [Hard Work Does Not Pay Off](#hard-work-does-not-pay-off)

  - [Read Code](#read-code)

  - [Read the Humanities](#read-the-humanities)

  - [Reinvent the Wheel Often](#reinvent-the-wheel-often)

  - [The Guru Myth](#the-guru-myth)

- Nocturnal or Magical

  - [Don't Rely on "Magic Happens Here"](#dont-rely-on-magic-happens-here)

  - [Don't Touch That Code](#dont-touch-that-code)

  - [Know How to Use Command-Line Tools](#know-how-to-use-command-line-tools)

  - [Test While You Sleep (And Over Weekends)](#test-while-you-sleep-and-over-weekends)

  - [Verbose Logging Will Disturb Your Sleep](#verbose-logging-will-disturb-your-sleep)

  - [The Guru Myth](#the-guru-myth)

  - [The Linker Is Not a Magical Program](#the-linker-is-not-a-magical-program)

  - [Write Code As If You Had to Support It for the Rest of Your Life](
    #write-code-as-if-you-had-to-support-it-for-the-rest-of-your-life)

- Performance, Optimisation, & Representation

  - [Apply Functional Programming Principles](#apply-functional-programming-principles)

  - [Floating-Point Numbers Aren't Real](#floating-point-numbers-arent-real)

  - [Improve Code by Removing It](#improve-code-by-removing-it)

  - [Interprocess Communication Affects Application Response Time](
    #interprocess-communication-affects-application-response-time)

  - [Know Your Limits](#know-your-limits)

  - [Large, Interconnected Data Belongs to a Database](#large-interconnected-data-belongs-to-a-database)

  - [Message Passing Leads to Better Scalability in Parallel Systems](
    #message-passing-leads-to-better-scalability-in-parallel-systems)

  - [The Road to Performance is Littered with Dirty Code Bombs](
    #the-road-to-performance-is-littered-with-dirty-code-bombs)

  - [Use the Right Algorithm and Data Structure](#use-the-right-algorithm-and-data-structure)

  - [WET Dilutes Performance Bottlenecks](#wet-dilutes-performance-bottlenecks)

- Professionalism, Mindset, & Attitude

  - [Continuous Learning](#continuous-learning)

  - [Do Lots of Deliberate Practice](#do-lots-of-deliberate-practice)

  - [Hard Work Does Not Pay Off](#hard-work-does-not-pay-off)

  - [Put the Mouse Down and Step Away from the Keyboard](#put-the-mouse-down-and-step-away-from-the-keyboard)

  - [Testing is the Engineering Rigour of Software Development](
    #testing-is-the-engineering-rigour-of-software-development)

  - [The Longevity of Interim Solutions](#the-longevity-of-interim-solutions)

  - [The Professional Programmer](#the-professional-programmer)

  - [Write Code As If You Had to Support It for the Rest of Your Life](
    #write-code-as-if-you-had-to-support-it-for-the-rest-of-your-life)

  - [You Gotta Care About the Code](#you-gotta-care-about-the-code)

- Programming Languages & Paradigms

  - [Apply Functional Programming Principles](#apply-functional-programming-principles)

  - [Domain-Specific Languages](#domain-specific-languages)

  - [Don't Just Learn the Language, Understand Its Culture](#dont-just-learn-the-language-understand-its-culture)

  - [Know Well More Than Two Programming Languages](#know-well-more-than-two-programming-languages)

  - [Learn Foreign Languages](#learn-foreign-languages)

- Refactoring & Code Care

  - [A Message to the Future](#a-message-to-the-future)

  - [Act with Prudence](#act-with-prudence)

  - [Before You Refactor](#before-you-refactor)

  - [Comment Only What the Code Cannot Say](#comment-only-what-the-code-cannot-say)

  - [Don't Be Afraid to Break Things](#dont-be-afraid-to-break-things)

  - [Improve Code by Removing It](#improve-code-by-removing-it)

  - [Keep the Build Clean](#keep-the-build-clean)

  - [Know Your Next Commit](#know-your-next-commit)

  - [Only the Code Tells the Truth](#only-the-code-tells-the-truth)

  - [Own (and Refactor) the Build](#own-and-refactor-the-build)

  - [Simplicity Comes from Reduction](#simplicity-comes-from-reduction)

  - [The Boy Scout Rule](#the-boy-scout-rule)

  - [The Longevity of Interim Solutions](#the-longevity-of-interim-solutions)

  - [The Professional Programmer](#the-professional-programmer)

  - [The Road to Performance is Littered with Dirty Code Bombs](
    #the-road-to-performance-is-littered-with-dirty-code-bombs)

  - [Ubuntu Coding for Your Friends](#ubuntu-coding-for-your-friends)

  - [You Gotta Care About the Code](#you-gotta-care-about-the-code)

- Reuse Versus Repetition

  - [Beware the Share](#beware-the-share)

  - [Convenience is Not an -ility](#convenience-is-not-an--ility)

  - [Do Lots of Deliberate Practice](#do-lots-of-deliberate-practice)

  - [Don't Repeat Yourself](#dont-repeat-yourself)

  - [Reinvent the Wheel Often](#reinvent-the-wheel-often)

  - [Use the Right Algorithm and Data Structure](#use-the-right-algorithm-and-data-structure)

- Schedules, Deadlines, & Estimates

  - [Act with Prudence](#act-with-prudence)

  - [Code is Design](#code-is-design)

  - [Know Your Next Commit](#know-your-next-commit)

  - [Learn to Estimate](#learn-to-estimate)

  - [Make the Invisible More Visible](#make-the-invisible-more-visible)

- Simplicity

  - [A Message to the Future](#a-message-to-the-future)

  - [Beauty Is in Simplicity](#beauty-is-in-simplicity)

  - [Learn to Say, "Hello, World"](#learn-to-say-hello-world)

  - [Simplicity Comes from Reduction](#simplicity-comes-from-reduction)

- Teamwork & Collaboration

  - [Code Reviews](#code-reviews)

  - [Learn Foreign Languages](#learn-foreign-languages)

  - [Pair Program and Feel the Flow](#pair-program-and-feel-the-flow)

  - [Start from Yes](#start-from-yes)

  - [Two Heads Are Often Better Than One](#two-heads-are-often-better-than-one)

  - [Ubuntu Coding for Your Friends](#ubuntu-coding-for-your-friends)

  - [When Programmers and Testers Collaborate](#when-programmers-and-testers-collaborate)

- Tests, Testing, & Testers

  - [Apply Functional Programming Principles](#apply-functional-programming-principles)

  - [Code is Design](#code-is-design)

  - [Don't Be Cute with Your Test Data](#dont-be-cute-with-your-test-data)

  - [Make Interfaces Easy to Use Correct and Hard to Use Incorrectly](
    #make-interfaces-easy-to-use-correct-and-hard-to-use-incorrectly)

  - [Make the Invisible More Visible](#make-the-invisible-more-visible)

  - [News of the Weird: Testers Are Your Friends](#news-of-the-weird-testers-are-your-friends)

  - [Test for Required Behaviour, Not Incidental Behaviour](#test-for-required-behaviour-not-incidental-behaviour)

  - [Test Precisely and Concretely](#test-precisely-and-concretely)

  - [Test While You Sleep (And Over Weekends)](#test-while-you-sleep-and-over-weekends)

  - [Testing is the Engineering Rigour of Software Development](
    #testing-is-the-engineering-rigour-of-software-development)

  - [The Golden Rule of API Design](#the-golden-rule-of-api-design)

  - [When Programmers and Testers Collaborate](#when-programmers-and-testers-collaborate)

  - [Write Small Functions Using Examples](#write-small-functions-using-examples)

  - [Write Tests for People](#write-tests-for-people)

- Tools, Automation, & Development Environments

  - [Automate Your Coding Standard](#automate-your-coding-standard)

  - [Check Your Code First Before Looking to Blame Others](#check-your-code-first-before-looking-to-blame-others)

  - [Choose Your Tools with Care](#choose-your-tools-with-care)

  - [Don't Repeat Yourself](#dont-repeat-yourself)

  - [How to Use a Bug Tracker](#how-to-use-a-bug-tracker)

  - [Know How to Use Command-Line Tools](#know-how-to-use-command-line-tools)

  - [Know Your IDE](#know-your-ide)

  - [Large, Interconnected Data Belongs to a Database](#large-interconnected-data-belongs-to-a-database)

  - [Learn to Say, "Hello, World"](#learn-to-say-hello-world)

  - [Let Your Project to Speak for Itself](#let-your-project-to-speak-for-itself)

  - [Put Everything Under Version Control](#put-everything-under-version-control)

  - [Step Back and Automate, Automate, Automate](#step-back-and-automate-automate-automate)

  - [Take Advantage of Code Analysis Tools](#take-advantage-of-code-analysis-tools)

  - [Test While You Sleep (And Over Weekends)](#test-while-you-sleep-and-over-weekends)

  - [The Linker Is Not a Magical Program](#the-linker-is-not-a-magical-program)

  - [The Unix Tools Are Your Friends](#the-unix-tools-are-your-friends)

- Users & Customers

  - [Ask, "What Would the User Do?" (You Are Not the User)](#ask-what-would-the-user-do-you-are-not-the-user)

  - [Domain-Specific Languages](#domain-specific-languages)

  - [Make Interfaces Easy to Use Correct and Hard to Use Incorrectly](
    #make-interfaces-easy-to-use-correct-and-hard-to-use-incorrectly)

  - [News of the Weird: Testers Are Your Friends](#news-of-the-weird-testers-are-your-friends)

  - [Prevent Errors](#prevent-errors)

  - [Read the Humanities](#read-the-humanities)

  - [Your Customers Do Not Mean What They Say](#your-customers-do-not-mean-what-they-say)

<details open>

<summary>Click to expand/minimise the full contents of this book.</summary>

### A Comment on Comments

- Comments are not evil. They are as necessary to programming as basic branching or looping constructs. Most modern
  languages have a tool akin to Javadoc that will parse properly formatted comments to automatically build an API
  document. This is a very good start, but not nearly enough. Inside your code should be explanations about what the
  code is supposed to be doing. Coding by the old adage, "If it was hard to write, it should be hard to read," does a
  disservice to your client, your employer, your colleagues, and your future self.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Make sure your comments clarify your code but do not obscure it. Sprinkle your code with relevant comments
  explaining what the code is supposed to accomplish. Your header comments should give any programmer enough
  information to use your code without having to read it, while your inline comments should assist the next developer
  in fixing or extending it.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### A Message to the Future

- It seems that programmers them think that since the problems they are struggling with are difficult, the solutions
  should be just as difficult for everyone (maybe even for themselves a few months after the code was written) to
  understand and maintain.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Act with Prudence

- If you find yourself having to choose between "doing it right" and "doing it quick," it is often appealing to "do it
  quick" with the understanding that you'll come back and fix it later.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Technical debt is like a loan: you benefit from it in the short term, but you have to pay interest on it until it is
  fully paid off. Shortcuts in the code make it harder to add features or refactor your code. They are breeding grounds
  for defects and brittle test cases. The longer you leave it, the worse it gets. By the time you get around to
  undertaking the original fix, there may be a whole stack of not-quite-right design choices layered on top of the
  original problem, making the code much harder to refactor and correct.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You must track technical debt and pay it back quickly, or things go rapidly downhill.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If you schedule repayment of the debt in the next iteration, the cost will be minimal. Leaving the debt unpaid will
  accrue interest, and that interest should be tracked to make the cost visible.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Apply Functional Programming Principles

- Functional programming has recently enjoyed renewed interest from the mainstream programming community. Part of the
  reason is because emergent properties of the functional paradigm are well positioned to address the challenges posed
  by our industry's shift toward multicore.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Mastery of the functional programming paradigm can greatly improve the quality of the code you write in other
  contexts.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If you deeply understand and apply the functional paradigm, your designs will exhibit a much higher degree of
  referential transparency. Referential transparency is a very desirable property: it implies that functions
  consistently yield the same results given the same input, irrespective of where and when they are invoked. That is,
  function evaluation depends less - ideally, not at all - on the side effects of mutable state.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Ask, "What Would the User Do?" (You Are Not the User)

- We all tend to assume that other people think like us. But they don't. Psychologists call this the false consensus
  bias. This bias explains why programmers have such a hard time putting themselves in the users' position. Users don't
  think like programmers.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The best way to find out how a user thinks is to watch one. Ask a user to complete a task using a similar piece of
  software to what you're developing. Avoid tasks that are too specific, such as "Can you select these spreadsheet
  cells and enter a SUM formula below?" - there's a big clue in that question. Get the user to talk through their
  progress. Don't interrupt. Don't try to help. Keep asking yourself, "Why are they doing that?"
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The first thing you'll notice is that users do a core of things similarly. They try to complete tasks in the same
  order - and they make the same mistakes in the same places. You should design around that core behaviour.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Users tend to muddle through. They'll find a way that works and stick with it, no matter how convoluted. It's better
  to provide one really obvious way of doing things than two or three shortcuts.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You'll also find that there's a gap between what users say they want and what they actually do.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Automate Your Coding Standard

- Well-formatted code doesn't earn you points with a customer that wants more functionality. Furthermore, following a
  coding standard can be quite a boring task if it isn't automated.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- One reason to format the code in a uniform way is so that nobody can "own" a piece of code just by formatting it in
  their private way. We may want to prevent developers from using certain antipatterns in order to avoid some common
  bugs. In all, a coding standard should make it easier to work in the project, and maintain development speed from the
  beginning to the end. It follows, then, that everybody should agree on the coding standard, too - it does not help if
  one developer uses three spaces to indent code, and another uses four.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- There exists a wealth of tools that can be used to produce code quality reports and to document and maintain the
  coding standard, but that isn't the whole solution. It should be automated and enforced where possible. Here are a
  few examples: [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make sure code formatting is part of the build process, so that everybody runs it automatically every time they
    compile the code.

  - Use static code analysis tools to scan the code for unwanted antipatterns. If any are found, break the build.

  - Learn to configure those tools so that you can scan for your own, project-specific antipatterns.

  - Do not only measure test coverage, but automatically check the results, too. Again, break the build if test
    coverage is too low.

- Try to do this for everything that you consider important. You won't be able to automate everything you really care
  about. As for the things that you can't automatically flag or fix, consider them a set of guidelines supplementary to
  the coding standard that is automated, but accept that you and your colleagues may not follow them as diligently.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The coding standard should be dynamic rather than static. As the project evolves, the needs of the project change,
  and what may have seemed smart in the beginning isn't necessarily smart a few months later.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Beauty Is in Simplicity

- Beautiful code is simple code. Each individual part is kept simple with simple responsibilities and simple
  relationships with the other parts of the system. This is the way we can keep our systems maintainable over time,
  with clean, simple, testable code, ensuring a high speed of development throughout the lifetime of the system.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Before You Refactor

- The best approach for restructuring starts by taking stock of the existing codebase and the tests written against
  that code. This will help you understand the strengths and weaknesses of the code as it currently stands, so you can
  ensure that you retain the strong points while avoiding the mistakes.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Avoid the temptation to rewrite everything. It is best to reuse as much code as possible. No matter how ugly the code
  is, it has already been tested, reviewed, etc. Throwing away the old code - especially if it was in production - means
  that you are throwing away months (or years) of tested, battle-hardened code that may have had certain workarounds
  and bug fixes you aren't aware of.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Many incremental changes are better than one massive change. Incremental changes allows you to gauge the impact on
  the system more easily through feedback, such as from tests.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- After each development iteration, it is important to ensure that the existing tests pass. Add new tests if the
  existing tests are not sufficient to cover the changes you made. Do not throw away the tests from the old code
  without due consideration.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Personal preferences and ego shouldn't get in the way. If something isn't broken, why fix it? That the style or the
  structure of the code does not meet your personal preference is not a valid reason for restructuring. Thinking you
  could do a better job than the previous programmer is not a valid reason, either.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- New technology is an insufficient reason to refactor. One of the worst reasons to refactor is because the current
  code is way behind all the cool technology we have today, and we believe that a new language or framework can do
  things a lot more elegantly.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Remember that humans make mistakes. Restructuring will not always guarantee that the new code will be better - or
  even as good as - the previous attempt.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Beware the Share

- Before reducing the number of lines of code, make sure you aren't increasing the number of dependencies, or the
  complexity of existing dependencies.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Check Your Code First Before Looking to Blame Others

- Any issues in code are most likely caused by your changes.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Choose Your Tools with Care

- Start only using the tools that are absolutely necessary.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Code in the Language of the Domain

- The following code is not very clear. It seems to be getting an ID from a trader object; using that to get a map out
  of a, well, map-of-maps, apparently; and then seeing if another ID from a portfolio object exists in the inner map.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  ```java
  if (portfolioIdsByTraderId.get(trader.getId()).containsKey(portfolio.getId())) {
    ...
  }

  Map<int, Map<int, int>> portfolioIdsByTraderId;
  ```

- You don't need to know how a trader knows. Perhaps there is one of these maps-of-maps tucked away somewhere inside.
  But that's the trader's business, not yours.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  ```java
  if (trader.canView(portfolio)) {
    ...
  }
  ```

- Making domain concepts explicit in your code means other programmers can gather the intent of the code much more
  easily than by trying to retrofit an algorithm into what they understand about a domain. It also means that when the
  domain model evolves - which it will, as your understanding of the domain grows - you are in a good position to
  evolve the code. Coupled with good encapsulation, the chances are good that the rule will exist in only one place,
  and that you can change it without any of the dependent code being any the wiser.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Code is Design

- The demand for quality, validated designs exceeds our ability to create them. There is a strong pressure to use
  incomplete design.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Code Layout Matters

- We all spend much more of our programming time navigating and reading code - finding where to make a change - than
  actually typing, so that's what we optimise for. Here are three such optimisations:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Compact Format**

    - The more you can get on a screen, the more you can see without breaking context by scrolling or switching files,
      which means you can keep less state in your head.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Long procedure comments and lots of whitespace made sense for eight-character names and line printers, but now
      with a modern IDE that does syntax colouring and cross linking.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - The layout should help understand the code, but no more than that.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Easy to Scan**

    - People are really good at visual pattern matching, so it can help by making everything that isn't directly
      relevant to the domain - all the "accidental complexity" that comes with most commercial languages - fade into
      the background by standardising it.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Expressive Layout**

    - It takes time to find the right names so that our code expresses as clearly as possible what it does, rather than
      just listing the steps. The code's layout is part of this expressiveness, too.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - A formatter cannot understand the programmer's intentions, it's more important that the line breaks and groupings
      reflect the intention of the code, not just the syntax of the language.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Code Reviews

- Instead of simply correcting mistakes in code, the purpose of code reviews should be to share knowledge and establish
  common coding guidelines. Sharing your code with other programmers enables collective code ownership. Instead of
  looking for errors, you should review the code by trying to learn and understand it.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Be gentle during code reviews. Ensure that comments are constructive, not caustic. Introduce different roles for the
  review meeting to avoid having organisational seniority among team members affect the code review. Examples of roles
  could include having one reviewer focus on documentation, another on exceptions, and a third to look at the
  functionality. This approach helps to spread the review burden across the team members.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Involve newbies in code reviews. They may be inexperienced, but their fresh university knowledge can provide a
  different perspective. Involve experts for their experience and knowledge. They will identify error-prone code faster
  and with more accuracy. Code reviews will flow more easily if the team has coding conventions that are checked by
  tools. That way, code formatting will never be discussed during the code review meeting.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Coding with Reason

- The underlying approach is to divide all the code under consideration into short sections - from a single line, such
  as a function call, to blocks of less than 10 lines.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Striving for sections to be as independent of one another as possible simplifies reasoning and is indispensable when
  these sections are to be modified.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Many of the coding practices that are well known and considered "good" make reasoning easier. Hence, just by
  intending to reason about your code, you already start moving toward a better style and structure. Unsurprisingly,
  most of these practices can be checked by static code analysers:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Avoid using goto statements, as they make remote sections highly interdependent.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Avoid using modifiable global variables, as they make all sections that use them dependent.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Each variable should have the smallest possible scope. For example, a local object can be declared right before its
    first usage.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make objects immutable whenever relevant.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make the code readable by using spacing, both horizontal and vertical - e.g., aligning related structures and using
    an empty line to separate two sections.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make the code self-documenting by choosing descriptive (but relatively short) names for objects, types, functions,
    etc.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - If you need a nested section, make it a function.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make your functions short and focused on a single task. The old 24-line limit still applies. Although screen size
    and resolution have changed, nothing has changed in human cognition since the 1960s.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Functions should have few parameters (four is a good upper bound). This does not restrict the data communicated to
    functions: grouping related parameters into a single object localises object invariants, which simplifies reasoning
    with respect to their coherence and consistency.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - More generally, each unit of code, from a block to a library, should have a narrow interface. Less communication
    reduces the reasoning required. This means that getters that return internal state are a liability - don't ask an
    object for information to work with. Instead, ask the object to do the work with the information it already has. In
    other words, encapsulation is all - and only - about narrow interfaces.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - In order to preserve class invariants, usage of setters should be discouraged. Setters tend to allow invariants
    that govern an object's state to be broken.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Comment Only What the Code Cannot Say

- When code is ill-formed, compilers, interpreters, and other tools will be sure to object. If the code is in some way
  functionally incorrect, reviews, static analysis, tests, and day-to-day use in a production environment will flush
  most bugs out, but comments often litter and survive in a codebase in a way that coding errors never could. They
  provide a constant source of distraction and misinformation, a subtle but constant distraction on a programmer's
  thinking.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Comments that are not technically wrong, but add no value to the code are noise. Comments that parrot the code offer
  nothing extra to the reader - stating something once in code and again in natural language does not make it any truer
  or more real. Commented-out code is not executable code, so it has no useful effect for either reader or runtime. It
  also becomes stale very quickly. Version-related comments and commented-out code try to address questions of
  versioning and history. These questions have already been answered (far more effectively) by version control tools.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A prevalence of noisy comments and incorrect comments in a codebase encourages programmers to ignore all comments,
  either by skipping past them or by taking active measures to hide them.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Comments should say something code does not and cannot say. A comment explaining what a piece of code should already
  say is an invitation to change code structure or coding conventions so the code speaks for itself. Instead of
  compensating for poor method or class names, rename them. Instead of commenting sections in long functions, extract
  smaller functions whose names capture the former sections' intent. Try to express as much as possible through code.
  Any shortfall between what you can express in code and what you would like to express in total becomes a plausible
  candidate for a useful comment.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Comment what the code cannot say, not simply what it does not say.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Continuous Learning

- Some employers are generous enough to provide training to broaden your skill set. Others may not be able to spare the
  time or money for any training at all. To play it safe, you need to take responsibility for your own education.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A list of ways to help you keep learning:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Read books, magazines, blogs, Twitter feeds, and websites, mailing lists, newsgroups, etc.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - If you really want to get immersed in a technology, get hands on - write some code.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Always try to work with a mentor, as being the top guy can hinder your education. Although you can learn something
    from anybody, you can learn a whole lot more from someone smarter or more experienced than you. If you can't find a
    mentor, consider moving on.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Use virtual mentors. Find authors and developers on the Web who you really like and read everything (or at least
    some of what) they write.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Get to know the frameworks and libraries you use. Knowing how something works makes you know how to use it better.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Whenever you make a mistake, fix a bug, or run into a problem, try to really understand what happened. It's likely
    that someone else ran into the same problem and posted it on the Web.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - A good way to learn something is to teach or speak about it. When people are going to listen to you and ask you
    questions, you'll be highly motivated to learn.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Go to conferences.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Long commute? Listen to podcasts.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Ever run a static analysis tool over the codebase or look at the warnings in your IDE? Understand what they're
    reporting and why.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Learn a new language every year. At least learn a new technology or tool. Branching out gives you new ideas you can
    use in your current technology stack.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Not everything you learn has to be about technology. Learn the domain you're working in so you can better
    understand the requirements and help solve the business problem. Learning how to be more productive - how to work
    better - is another good option.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Convenience is Not an -ility

- Good API design comes from the following "insights":
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Don't require API users make two separate calls to do one things.

  - Why make another method if it's almost the same as an existing method? Just add a simple `switch`.

- The following is a bad example of a method call to an API:

  ```java
  parser.processNodes(text, false);
  ```

- The following is a better example of a method call to an API:

  ```java
  parser.processNodes("example_text_file", "txt");
  ```

- APIs are supposed to hide underlying complexity, so we can realistically expect good API design to require some
  effort. A single large method could certainly be more convenient to write than a well-thought-out set of operations,
  but would it be easier to use?
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Deploy Early and Often

- The installation/deployment process is the first thing that the customer sees, and a simple one is the first step to
  having a reliable (or, at least, easy to debug) production environment. The deployed software is what the customer
  will use. By not ensuring that the deployment sets up the application correctly, you'll raise questions with your
  customers before they get to use your software thoroughly.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Starting your project with an installation process will give you time to evolve the process as you move through the
  product development cycle, and the chance to make changes to the application code to make the installation easier.
  Running and testing the installation process on a clean environment periodically also provides a check that you have
  not made assumptions in the code that rely on the development or test environments.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Putting deployment last means that the deployment process may need to be more complicated to work around assumptions
  in the code. What seemed a great idea in an IDE, where you have full control over an environment, might make for a
  much more complicated deployment process. It is better to know all the trade-offs sooner rather than later.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Distinguish Business Exceptions from Technical

- There are basically two reasons that things go wrong at runtime: technical problems that prevent us from using the
  application and business logic that prevents us from misusing the application.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- An unresolvable technical problem can occur when there is a programming error. For example, if you try to access
  element 83 from an array of size 17, then the program is clearly off track, and some exception should result. The
  subtler version is calling some library code with inappropriate arguments, causing the same situation on the inside
  of the library.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Mixing technical exceptions and business exceptions in the same hierarchy blurs the distinction and confuses the
  caller about what the method contract is, what conditions it is required to ensure before calling, and what
  situations it is supposed to handle. Separating the cases gives clarity and increases the chances that technical
  exceptions will be handled by some application framework, while the business domain exceptions actually are
  considered and handled by the client code.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Do Lots of Deliberate Practice

- You do deliberate practice to improve your ability to perform a task. It's about skill and technique. Deliberate
  practice means repetition. It means performing the task with the aim of increasing your mastery of one or more
  aspects of the task.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The principal aim of paid development is to finish a product, whereas the principal aim of deliberate practice is to
  improve your performance. They are not the same. Deliberate practice is about learning - learning that changes you,
  learning that changes your behaviour.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Domain-Specific Languages

- Domain-Specific Languages (DSLs) are a specific domain has a specialised vocabulary to describe the things that are
  particular to that domain.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- In the world of software, DSLs are about executable expressions in a language specific to a domain, employing a
  limited vocabulary and grammar that is readable, understandable, and - hopefully - writeable by domain experts.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- DSLs are commonly classified as either internal or external:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Internal DSLs**:

    - Written in a general-purpose programming language whose syntax has been bent to look much more like natural
      language. This is easier for languages that offer more syntactic sugar and formatting possibilities (e.g., Ruby
      and Scala) than it is for others that do not (e.g., Java).
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Most internal DSLs wrap existing APIs, libraries, or business code and provide a wrapper for less mind-bending
      access to the functionality.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Depending on the implementation and the domain, they are used to build data structures, define dependencies, run
      processes or tasks, communicate with other systems, or validate user input.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **External DSLs**:

    - Are textual or graphical expressions of the language - although textual DSLs tend to be more common than
      graphical ones. Textual expressions can be processed by a toolchain that includes a lexer, parser, model
      transformer, generators, and any other type of post-processing. External DSLs are mostly read into internal
      models that form the basis for further processing.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Defining external DSLs as XML dialects is also quite common, although readability is often an issue - especially
      for non-technical readers.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You must always take the target audience of your DSL into account. Are they developers, managers, business
  customers, or end users? You have to adapt the technical level of the language, the available tools, syntax help
  (e.g., IntelliSense), early validation, visualisation, and representation to the intended audience.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Be Afraid to Break Things

- Don't be afraid of your code. Who cares if something gets temporarily broken while you move things around? A
  paralysing fear of change is what could have gotten a project into this state to begin with. Investing the time to
  refactor will pay for itself several times over the lifecycle of your project. An added benefit is that your team's
  experience dealing with the sick system makes you all experts in knowing how it should work.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Redefine internal interfaces, restructure modules, refactor copypasted code, and simplify your design by reducing
  dependencies. You can significantly reduce code complexity by eliminating corner cases, which often result from
  improperly coupled features. Slowly transition the old structure into the new one, testing along the way. Trying to
  accomplish a large refactor in "one big shebang" will cause enough problems to make you consider abandoning the whole
  effort midway through.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Be Cute with Your Test Data

- When writing any text in your code - whether comments, logging, dialogues, or test data - always ask yourself how it
  will look if it becomes public.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Ignore That Error

- If you ignore an error, turn a blind eye, and pretend that nothing has gone wrong, you run great risks. Deal with
  problems at the earliest opportunity. Keep a short account.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Not handling errors leads to:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Brittle code**:
  
    - Code that's filled with exciting, hard-to-find bugs.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Insecure code**:
  
    - Crackers often exploit poor error handling to break into software systems.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Poor structure**:

    - If there are errors from your code that are tedious to deal with continually, you probably have a poor interface.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Express it so that the errors are less intrusive and their handling is less onerous.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Just as you should check all potential errors in your code, you need to expose all potentially erroneous conditions
  in your interfaces. Do not hide them, pretending that your services will always work.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Just Learn the Language, Understand Its Culture

- It takes more than just learning the syntax to learn a language: you need to understand its culture.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Once you've learned the ropes of a new language, you'll be surprised how you'll start using languages you already
  know in new ways. You'll also get a better understanding of design patterns by moving between different languages. C
  programmers find that C# and Java have commoditised the iterator pattern. In Ruby and other dynamic languages, you
  might still use a visitor, but your implementation won't look like the example from the Gang of Four book.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Nail Your Program into the Upright Position

- Handle all exceptions gracefully. Users should never have to see exception reports.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Rely on "Magic Happens Here"

- The persistent vision that software development can be simplified by removing programming is, to the programmer who
  understands what is involved, obviously nave. But the mental process that leads to this mistake is part of human
  nature, and programmers are just as prone to making it as everyone else.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When you aren't actively involved in things, there is an unconscious tendency to assume that they are simple and
  happen "by magic." While the magic continues to happen, all is well. But when - it is usually "when" and not "if " -
  the magic stops, the project is in trouble.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You don't have to understand all the magic that makes your project work, but it doesn't hurt to understand some of it
  or to appreciate someone who understands the bits you don't. Most importantly, make sure that when the magic stops,
  it can be started again.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Repeat Yourself

- The developer who learns to recognise duplication, and understands how to eliminate it through appropriate practice
  and proper abstraction, can produce much cleaner code than one who continuously infects the application with
  unnecessary repetition.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

#### Duplication is Waste

- Every line of code that goes into an application must be maintained, and is a potential source of future bugs.
  Duplication needlessly bloats the codebase, resulting in more opportunities for bugs and adding accidental complexity
  to the system. The bloat that duplication adds to the system also makes it more difficult for developers working with
  the system to fully understand the entire system, or to be certain that changes made in one location do not also need
  to be made in other places that duplicate the logic they are working on.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

#### Repetition in Process Calls for Automation

- Manual testing is slow, error-prone, and difficult to repeat, so automated test suites should be used where possible.
  Integrating software can be time consuming and error-prone if done manually, so a build process should be run as
  frequently as possible, ideally with every check-in. Wherever painful manual processes exist that can be automated,
  they should be automated and standardised. The goal is to ensure that there is only one way of accomplishing the
  task, and it is as painless as possible.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

#### Repetition in Logic Calls for Abstraction

- Repetition in logic can take many forms. Copy-and-paste `if-then` or `switch-case` logic is among the easiest to
  detect and correct. Many design patterns have the explicit goal of reducing or eliminating duplication in logic
  within an application. If an object typically requires several things to happen before it can be used, this can be
  accomplished with an Abstract Factory or a Factory Method pattern. If an object has many possible variations in its
  behaviour, these behaviours can be injected using the Strategy pattern rather than large `if-then` structures. In
  fact, the formulation of design patterns themselves is an attempt to reduce the duplication of effort required to
  solve common problems and discuss such solutions.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

#### A Matter of Principle

- When followed with regard to structure, logic, process, and function, the DRY principle provides fundamental guidance
  to software developers and aids the creation of simpler, more maintainable, higher-quality applications. While there
  are scenarios where repetition can be necessary to meet performance or other requirements (e.g., data denormalisation
  in a database), it should be used only where it directly addresses an actual rather than an imagined problem.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Don't Touch That Code

- A developer should not have access to a staging server.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- In most web-based development environments, the architecture can be broken down like this:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Local development and unit testing on the developer's machine
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Development server where manual or automated integration testing is done
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Staging server where the QA team and the users do acceptance testing
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Production server
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Under no circumstances - ever, at all - should a developer have access to a production server. If there is a problem,
  your support staff should either fix it or request that you fix it. After it's checked into SCC, they will roll a
  patch from there.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Encapsulate Behaviour, Not Just State

- Modules and packages address the larger-scale needs for encapsulation, while classes, subroutines, and functions
  address the more fine-grained aspects of the matter.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A class with a single 3,000-line main method, or a class with only set and get methods for its primitive attributes
  demonstrate that the developers involved have not fully understood object-oriented thinking, having failed to take
  advantage of the power of objects as modelling constructs.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- An object encapsulates both state and behaviour, where the behaviour is defined by the actual state. Consider a
  `Door` object. It has four states: closed, open, closing, opening. It provides two operations: open and close.
  Depending on the state, the open and close operations will behave differently. This inherent property of an object
  makes the design process conceptually simple. It boils down to two simple tasks: allocation and delegation of
  responsibility to the different objects including the inter-object interaction protocols.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Let's say we have three classes: `Customer`, `Order`, and `Item`. A `Customer` object is the natural placeholder for
  the credit limit and credit validation rules. An `Order` object knows about its associated `Customer`, and its
  `addItem` operation delegates the actual credit check by calling `customer.validateCredit(item.price())`. If the
  postcondition for the method fails, an exception can be thrown and the purchase aborted.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Less experienced object-oriented developers might decide to wrap all the business rules into an object very often
  referred to as `OrderManager` or `OrderService`. In these designs, `Order`, `Customer`, and `Item` are treated as
  little more than record types. All logic is factored out of the classes and tied together in one large, procedural
  method with a lot of internal if-then-else constructs. These methods are easily broken and are almost impossible to
  maintain because the encapsulation is broken.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Floating-Point Numbers Aren't Real

- You shouldn't use floating-point numbers for financial applications - that's what decimal classes in languages like
  Python and C# are for. Floating-point numbers are intended for efficient scientific computation. But efficiency is
  worthless without accuracy, so remember the source of rounding errors, and code accordingly.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Fulfil Your Ambitions with Open Source

- Open source provides enormous opportunities for the motivated programmer. First, you get to see how someone else
  would implement a solution that interests you - you can learn a lot by reading other people's source code. Second,
  you get to contribute your own code and ideas to the project - not every brilliant idea you have will be accepted,
  but some might, and you'll learn something new just by working on solutions and contributing code. Third, you'll meet
  great people with the same passion for the type of software that you have - these open source friendships can last a
  lifetime. Fourth, assuming you are a competent contributor, you'll be able to add real-world experience in the
  technology that actually interests you.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Getting started with open source is pretty easy. There is a wealth of documentation out there on the tools you'll
  need (source code management, editors, programming languages, build systems, etc.). Find the project you want to work
  on first and learn about the tools that project uses. The documentation on projects themselves will be light in most
  cases, but this perhaps matters less because the best way to learn is to investigate the code yourself. If you want
  to get involved, you could offer to help out with the documentation. Or you could start by volunteering to write test
  code. While that may not sound exciting, the truth is you learn much faster by writing test code for other people's
  software than almost any other activity in software. Write test code, really good test code. Find bugs, suggest
  fixes, make friends, work on software you like, and fulfil your software development ambitions.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Hard Work Does Not Pay Off

- Professional programming is usually not like running hard for a few kilometres, where the goal can be seen at the end
  of a paved road. Most software projects are more like a long orienteering marathon. In the dark. With only a sketchy
  map as guidance. If you just set off in one direction, running as fast as you can, you might impress some, but you
  are not likely to succeed. You need to keep a sustainable pace, and you need to adjust the course when you learn more
  about where you are and where you are heading.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Be focused on the project, contribute as much as you can by finding smart solutions, improve your skills, reflect on
  what you are doing, and adapt your behaviour.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- As a professional programmer, you should know that trying to be focused and "productive" 60 hours a week is not a
  sensible thing to do. Act like a professional: prepare, effect, observe, reflect, and change.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### How to Use a Bug Tracker

- A good bug report needs to convey three things:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - How to reproduce the bug, as precisely as possible, and how often this will make the bug appear.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - What should have happened, at least in your opinion.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - What actually happened, or at least as much information as you have recorded.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The amount and quality of information reported in a bug says as much about the reporter as it does about the bug.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Bugs are like a conversation, with all the history right there in front of everyone. Don't blame others or deny the
  bug's very existence. Instead, ask for more information or consider what you could have missed.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Improve Code by Removing It

- Some reasons why unnecessary code may be added to a project:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Write code because it adds value, not because it amuses you.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - If you don't need code right now, don't write it right now.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - It always takes longer to write and to maintain extra code. A small, extra bit of code snowballs over time into a
    large piece of work that needs maintenance.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Programmers do not set system requirements; the customer does. A programmer should not add code for non-existent
    or non-documented requirements, without a very good reason.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Interprocess Communication Affects Application Response Time

- Response time is critical to software usability. Few things are as frustrating as waiting for some software system to
  respond, especially when our interaction with the software involves repeated cycles of stimulus and response.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Much of modern performance management literature still focuses on data structures and algorithms, issues that can
  make a difference in some cases but are far less likely to dominate performance in modern multi-tier enterprise
  applications.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Each remote interprocess communication contributes some non-negligible latency to the overall response time, and
  these individual contributions add up, especially when they are incurred in sequence.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- There are a few relatively obvious and well-known strategies for reducing the number of remote interprocess
  communications per stimulus. One strategy is to apply the principle of parsimony, optimising the interface between
  processes so that exactly the right data for the purpose at hand is exchanged with the minimum amount of interaction.
  Another strategy is to parallelise the interprocess communications where possible, so that the overall response time
  becomes driven mainly by the longest-latency IPC. A third strategy is to cache the results of previous IPCs, so that
  future IPCs may be avoided by hitting local cache instead.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When you're designing an application, be mindful of the number of interprocess communications in response to each
  stimulus. When analysing applications that suffer from poor performance, you may find IPC-to-stimulus ratios of
  thousands-to-one. Reducing this ratio, whether by caching or parallelising or some other technique, will pay off much
  more than changing data structure choice or tweaking a sorting algorithm.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Keep the Build Clean

- When starting a new project from scratch, there are no warnings, no clutter, no problems. But as the codebase grows,
  if you don't pay attention, the clutter, the cruft, the warnings, and the problems can start piling up. When there's
  a lot of noise, it's much harder to find the warning that you really want to read among the hundreds of warnings you
  don't care about.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- To make warnings useful again, try to use a zero-tolerance policy for warnings from the build. Even if the warning
  isn't important, deal with it. If it's not critical but still relevant, fix it.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Know How to Use Command-Line Tools

- By working with command-line build tools, you will learn a lot more about what the tools are doing when your project
  is being built. Experimenting with the many command-line options for these tools is a valuable educational
  experience.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- There are some tasks that can be performed more easily or more efficiently with command-line tools than with an IDE.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Command-line tools inherently support scripting, which allows for the automation of tasks such as producing scheduled
  daily builds, creating multiple versions of a project, and running test suites.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Know Well More Than Two Programming Languages

- Every programmer starts with one programming language. That language has a dominating effect on the way that
  programmer thinks about software.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A programmer who learns a second language will be challenged, especially if that language has a different
  computational model than the first.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- We can enumerate a number of paradigms of computation: procedural, object-oriented, functional, logic, dataflow, etc.
  Moving among these paradigms creates the greatest challenges.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The consequence of all this is that it behoves every programmer to be well skilled in programming in at least two
  different paradigms, and ideally at least the aforementioned five.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Programmers should always be interested in learning new languages, preferably from an unfamiliar paradigm. Even if
  their day job always uses the same programming language, the increased sophistication of use of that language when a
  person can cross-fertilise from other paradigms should not be underestimated.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Know Your IDE

- Modern IDEs do not require us to invest effort to learn how to use them. Modern IDEs have a very gradual learning
  curve, which can have the effect that we never progress beyond the most basic usage of the tool.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Know Your Limits

- You only have so much time and money to do your work, including the time and money needed to keep your knowledge,
  skills, and tools up to date. You can only work so hard, so fast, so smart, and so long. Your tools are only so
  powerful. Your target machines are only so powerful. So you have to respect the limits of your resources.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- How to respect those limits? Know yourself, know your people, know your budgets, and know your stuff. Especially, as
  a software engineer, know the space and time complexity of your data structures and algorithms, and the architecture
  and performance characteristics of your systems. Your job is to create an optimal marriage of software and systems.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Know Your Next Commit

- Know your next commit. If you cannot finish, throw away your changes, then define a new task you believe in with the
  insights you have gained. Do speculative experimentation whenever needed, but do not let yourself slip into
  speculative mode without noticing. Do not commit guesswork into your repository.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Large, Interconnected Data Belongs to a Database

- If your application is going to handle a large, persistent, interconnected set of data elements, don't hesitate to
  store it in a relational database.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- In the past, RDBMSes (Relational Database Systems) used to be expensive, scarce, complex, and unwieldy beasts. This
  is no longer the case. Nowadays, RDBMSes are easy to find - it is likely that the system you're using already has one
  or two installed. Some very capable RDBMSes, like MySQL and PostgreSQL, are available as open source software, so
  cost of purchase is no longer an issue. Even better, so-called embedded database systems can be linked as libraries
  directly into your application, requiring almost no setup or management - two notable open source ones are SQLite and
  HSQLDB (HyperSQL DataBase). These systems are extremely efficient.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Benefits of RDBMSes:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - A single SQL command can perform complex data changes. For one-off modifications - say, a change in the way you
    organise your persistent data - you don't even need to write code: just fire up the database's direct SQL
    interface.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - You can describe consistency constraints on your data in a declarative way, avoiding the risk of the dangling
    pointers you get if you forget to update your data in an edge case. For example, you can specify that if a user is
    deleted, then the messages sent by that user should be removed as well.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - After you've stored your properly normalised data in the database, it's easy to extract facts efficiently with a
    readable SQL query; there's no need to write any complex code.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - You can also create efficient links between the entities stored in the database any time you want, simply by
    creating an index. There is no need to perform expensive and extensive refactoring of class fields.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Coding around a database allows multiple applications to access your data in a safe way. This makes it easy to
    upgrade your application for concurrent use and also to code each part of your application using the most
    appropriate language and platform.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Keep in mind that the RDBMSes will sweat hard to optimise your SQL commands, allowing you to concentrate on your
  application's functionality rather than on algorithmic tuning.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Learn Foreign Languages

- Beyond communication with machine, self, and peers, a project has many stakeholders, most with a different or no
  technical background. You need to understand them and their concerns. This is almost impossible if you cannot speak
  their language - the language of their world, their domain. While you might think a conversation with them went well,
  they probably didn't.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- All these domain-specific languages need to be mastered by someone in the project - ideally, the programmers.
  Programmers are ultimately responsible for bringing the ideas to life via a computer.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Learn to Estimate

- As a programmer, you need to be able to provide estimates to your managers, colleagues, and users for the tasks you
  need to perform, so that they will have a reasonably accurate idea of the time, costs, technology, and other
  resources needed to achieve their goals.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- To be able to estimate well, it is obviously important to learn some estimation techniques. First of all, however, it
  is fundamental to learn what estimates are, and what they should be used for - as strange as it may seem, many
  developers and managers don't really know this.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- In order to estimate accurately, we need three definitions - estimate, target, and commitment:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Estimate**:

    - An estimate is an approximate calculation or judgment of the value, number, quantity, or extent of something.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - This definition implies that an estimate is a factual measure based on hard data and previous experience - hopes
      and wishes must be ignored when calculating it.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - The definition also implies that, being approximate, an estimate cannot be precise, e.g., a development task
      cannot be estimated to last 234.14 days.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Target**:

    - A statement of a desirable business objective, e.g., "The system must support at least 400 concurrent users."
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Commitment**:

    - A promise to deliver specified functionality at a certain level of quality by a certain date or event, e.g., "The
      search functionality will be available in the next release of the product."
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Estimates, targets, and commitments are independent from one another, but targets and commitments should be based on
  sound estimates.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Learn to Say, "Hello, World"

- It can often help to create a small standalone project to test a change without any external dependencies.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Let Your Project to Speak for Itself

- You need to give your project a voice. This can be done by email or instant messaging, informing the developers about
  the latest decline or improvement in the metrics in your project, such as code coverage, installation times, etc.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Make Interfaces Easy to Use Correct and Hard to Use Incorrectly

- One of the most common tasks in software development is interface specification. Interfaces occur at the highest
  level of abstraction (user interfaces), at the lowest (function interfaces), and at levels in between (class
  interfaces, library interfaces, etc.). Regardless of whether you work with end users to specify how they'll interact
  with a system, collaborate with developers to specify an API, or declare functions private to a class, interface
  design is an important part of your job. If you do it well, your interfaces will be a pleasure to use and will boost
  others' productivity. If you do it poorly, your interfaces will be a source of frustration and errors.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Good interfaces are:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Easy to Use Correctly**:

    - People using a well-designed interface almost always use the interface correctly, because that's the path of
      least resistance. In a GUI, they almost always click on the right icon, button, or menu entry, because it's the
      obvious and easy thing to do. In an API, they almost always pass the correct parameters with the correct values,
      because that's what's most natural. With interfaces that are easy to use correctly, things just work.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Hard to Use Incorrectly**:

    - Good interfaces anticipate mistakes people might make, and make them difficult - ideally, impossible - to commit.
      A GUI might disable or remove commands that make no sense in the current context, for example, or an API might
      eliminate argument-ordering problems by allowing parameters to be passed in any order.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A good way to design interfaces that are easy to use correctly is to exercise them before they exist.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Making interfaces hard to use incorrectly requires two things. First, you must anticipate errors users might make and
  find ways to prevent them. Second, you must observe how an interface is misused during early release and modify the
  interface to prevent such errors.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If users keep wanting to undo an irrevocable action, try to make the action revocable. If they keep passing the wrong
  value to an API, do your best to modify the API to take the values that users want to pass.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Remember that interfaces exist for the convenience of their users, not their implementers.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Make the Invisible More Visible

- Software and the process of developing it can be mostly invisible:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Source code has no innate presence, no innate behaviour, and doesn't obey the laws of physics. It's visible when
    you load it into an editor, but close the editor and it's gone.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - A running application has presence and behaviour, but reveals nothing of the source code it was built from.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - If you're 90% done and endlessly stuck trying to debug your way through the last 10%, then you're not 90% done, are
    you? Fixing bugs is not making progress. You aren't paid to debug. Debugging is waste. It's good to make waste more
    visible so you can see it for what it is and start thinking about trying not to create it in the first place.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - If your project is apparently on track, and one week later it's six months late, you have problems - the biggest of
    which is probably not that it's six months late, but the invisibility force fields powerful enough to hide six
    months of lateness.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Invisibility can be dangerous. You think more clearly when you have something concrete to tie your thinking to. You
  manage things better when you can see them and see them constantly changing:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Writing unit tests provides evidence about how easy the code unit is to unit test. It helps reveal the presence (or
    absence) of developmental qualities you'd like the code to exhibit, such as low coupling and high cohesion.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Running unit tests provides evidence about the code's behaviour. It helps reveal the presence (or absence) of
    runtime qualities you'd like the application to exhibit, such as robustness and correctness.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Tracking work can tickets can be used to show that work's status as *Not Started*, *In Progress*, or *Don*e without
    reference to a hidden project management tool and without having to chase programmers for fictional status reports.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Doing incremental development increases the visibility of development progress (or lack of it) by increasing the
    frequency of development evidence.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- It's best to develop software with plenty of regular visible evidence. Visibility gives confidence that progress is
  genuine and not an illusion, deliberate and not unintentional, repeatable and not accidental.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Message Passing Leads to Better Scalability in Parallel Systems

- Concurrency - and especially parallelism, a special subset of concurrency - is hard, that only the very best can ever
  hope to get it right, and even they get it wrong.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Almost all the problems of concurrency that people go on and on about relate to the use of shared mutable memory:
  race conditions, deadlock, livelock, etc. The answer seems obvious: either forgo concurrency or eschew shared memory.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Forgoing concurrency is almost certainly not an option. Computers have more and more cores on an almost quarterly
  basis, so harnessing true parallelism becomes more and more important. We can no longer rely on ever-increasing
  processor clock speeds to improve application performance. So we can eschew shared memory.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Instead of using threads and shared memory as our programming model, we can use processes and message passing.
  Process here just means a protected independent state with executing code, not necessarily an operating system
  process.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Not programming with shared memory, but instead using message passing, is likely to be the most successful way of
  implementing systems that harness the parallelism that is now endemic in computer hardware.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Missing Opportunities for Polymorphism

- In the context of programming, polymorphism refers to many forms of a particular class of objects or method. But
  polymorphism isn't simply about alternate implementations. Used carefully, polymorphism creates tiny localised
  execution contexts that let us work without the need for verbose if-then-else blocks. Being in a context allows us to
  do the right thing directly, whereas being outside of that context forces us to reconstruct it so that we can then do
  the right thing.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- With careful use of alternate implementations, we can capture context that can help us produce less code that is more
  readable.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - This is best demonstrated with some code, such as the following (unrealistically) simple shopping cart:
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    ```java
    public class ShoppingCart {
      private ArrayList<Item> cart = new ArrayList<Item>();

      public void add(Item item) {
        cart.add(item);
      }

      public Item takeNext() {
        return cart.remove(0);
      }

      public boolean isEmpty() {
        return cart.isEmpty();
      }
    }
    ```

  - Let's say our webshop offers items that can be downloaded and items that need to be shipped. Let's build another
    object that supports these operations:
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    ```java
    public class Shipping {
      public boolean ship(Item item, SurfaceAddress address) {
        ...
      }

      public boolean ship(Item item, EMailAddress address {
        ...
      }
    }
    ```

  - When a client has completed checkout, we need to ship the goods:
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    ```java
    while (!cart.isEmpty()) {
      shipping.ship(cart.takeNext(), ???);
    }
    ```

  - The `???` parameter is asking where to email or snail-mail the item. The context needed to answer this question no
    longer exists. We have could captured the method of shipment in a `boolean` or `enum` and then used an
    `if-then-else` to fill in the missing parameter. Another solution would be to create two classes that both extend
    `Item`. Let's call these `DownloadableItem` and `SurfaceItem`, both implementing a `ship` method:
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    ```java
    public class DownloadableItem implements Item {
      public boolean ship(Shipping shipper, Customer customer) {
        shipper.ship(this, customer.getEmailAddress());
      }
    }

    public class SurfaceItem implements Item {
      public boolean ship(Shipping shipper, Customer customer) {
        shipper.ship(this, customer.getSurfaceAddress());
      }
    }
    ```

- While there are cases where it's much more practical to use `if-then-else` instead of polymorphism, it is more often
  the case that a more polymorphic coding style will yield a smaller, more readable and less fragile codebase. The
  number of missed opportunities is a simple count of the `if-then-else` statements in our code.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### News of the Weird: Testers Are Your Friends

- Programmers often have an adversarial relationship with the people who test their software.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You may think the testers make you look bad by reporting trivial issues. But when customers are thrilled because they
  weren't bothered by all those "little things" that QC made you fix, then you look great.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### One Binary

- Build a single binary that you can identify and promote through all the stages in the release pipeline. Hold
  environment-specific details in the environment.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Keep the environment information versioned, too. There's nothing worse than breaking an environment configuration and
  not being able to figure out what changed. The environmental information should be versioned separately from the
  code, since they'll change at different rates and for different reasons.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Only the Code Tells the Truth

- When you look at the source code, the meaning of the program should be apparent. To know what a program does, the
  source is ultimately all you can be sure of looking at. Even the most accurate requirements document does not tell
  the whole truth: it does not contain the detailed story of what the program is actually doing, only the high-level
  intentions of the requirements analyst.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A design document may capture a planned design, but it will lack the necessary detail of the implementation. These
  documents are likely to have lost sync with the current implementation.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- What can you do to actually make your code tell the truth as clearly as possible?
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Strive for good names.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Structure your code with respect to cohesive functionality, which also eases naming.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Decouple your code to achieve orthogonality.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Write automated tests explaining the intended behaviour and check the interfaces.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Refactor mercilessly when you learn how to code a simpler, better solution.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Make your code as simple as possible to read and understand.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Treat your code like any other composition, such as a poem, an essay, a public blog, or an important email. Craft
  what you express carefully, so that it does what it should and communicates as directly as possible what it is doing;
  so that it still communicates your intention when you are no longer around. Remember that useful code is used much
  longer than ever intended.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Own (and Refactor) the Build

- It is not uncommon for teams that are otherwise highly disciplined about coding practices to neglect build scripts,
  either out of a belief that they are merely an unimportant detail or from a fear that they are complex and need to be
  tended to by release engineers. Unmaintainable build scripts with duplication and errors cause problems of the same
  magnitude as those in poorly factored code.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The code is useless without being built, and the build is what defines the component architecture of the application.
  The build is an essential part of the development process, and decisions about the build process can make the code
  and the coding simpler.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Understanding the build can simplify the entire development lifecycle and reduce costs. Automating configuration in
  the build can enable you to get consistent results when multiple people are working on a project, avoiding an "it
  works for me" conversation. Many build tools allow you to run reports on code quality, allowing you to sense
  potential problems early.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Pair Program and Feel the Flow

- To succeed with pair programming, both individual team members and the team as a whole have to put forth some effort.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- As a team member, be patient with developers less experienced than you. Confront your fears about being intimidated
  by more skilled developers. Realise that people are different, and value it. Be aware of your own strengths and
  weaknesses, as well as those of other team members. You may be surprised by how much you can learn from your
  colleagues.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- There are numerous situations where flow can be broken, but where pair programming helps you keep it:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Reduce the "Truck Factor"**:

    - It's a slightly morbid thought experiment, but how many of your team members would have to be hit by a truck
      before the team became unable to complete the final deliverable? In other words, how dependent is your delivery
      on certain team members?
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Is knowledge privileged or shared? If you have been rotating tasks among pairs, there is always someone else who
      has the knowledge and can complete the work. Your team's flow is not as affected by the "truck factor."
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Solve Problems Effectively**:

    - If you are pair programming and you run into a challenging problem, you always have someone to discuss it with.
      Such dialogue is more likely to open up possibilities than if you are stuck by yourself.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - As the work rotates, your solution will be revisited and reconsidered by the next pair, so it does not matter if
      you did not choose the optimal solution initially.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Integrate Smoothly**:

    - If your current task involves calling another piece of code, you hope the names of the methods, the docs, and the
      tests are descriptive enough to give you a grasp of what it does. If not, pairing with a developer who was
      involved in writing that code will give you better overview and faster integration into your own code.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Additionally, you can use the discussion as an opportunity to improve the naming, docs, and testing.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Mitigate Interruptions**:

    - If someone comes over to ask you a question, or your phone rings, or you have to answer an urgent email, or you
      have to attend a meeting, your pair programming partner can keep on coding.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - When you return, your partner is still in the flow and you will quickly catch up and rejoin him.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Bring New Team Members Up to Speed Quickly**:

    - With pair programming, and a suitable rotation of pairs and tasks, newcomers quickly get to know both the code
      and the other team members.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Prefer Domain-Specific Types to Primitive Types

- Using classes such as Velocity_In_Knots and Distance_In_Nautical_Miles adds a lot of value with respect to code
  quality:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - The code becomes more readable, as it expresses concepts of a domain, not just Float or String.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - The code becomes more testable, as the code encapsulates behaviour that is easily testable.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - The code facilitates reuse across applications and systems.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The approach is equally valid for users of both statically and dynamically typed languages. The only difference is
  that developers using statically typed languages get some help from the compiler, while those embracing dynamically
  typed languages are more likely to rely on their unit tests. The style of checking may be different, but the
  motivation and style of expression is not.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Start exploring domain-specific types for the purpose of developing quality software.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Prevent Errors

- Error messages are the most critical interactions between the user and the rest of the system. They happen when
  communication between the user and the system is near the breaking point.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- It is easy to think of an error as being caused by a wrong input from the user. However, people make mistakes in
  predictable, systematic ways. So it is possible to "debug" the communication between the user and the rest of the
  system just as you would between other system components.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Cues are different from instructions: cues tend to be hints; instructions are verbose. Cues occur at the point of
  interaction; instructions appear before the point of interaction. Cues provide context; instructions dictate use.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Another way of avoiding errors is to offer defaults.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Whatever the cause, systems should be tolerant of errors. You can facilitate this by providing multiple levels of
  undo to all actions - and, in particular, actions that have the potential to destroy or amend users' data.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Most errors are systematic - the result of misunderstandings between the user and the software. Understanding how
  users think, interpret information, make decisions, and input data will help you debug the interactions between your
  software and your users.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Put Everything Under Version Control

- When you set up your project, don't be stingy: place all the project's assets under version control. In addition to
  the source code, include the documentation, tools, build scripts, test cases, artwork, and even libraries. With the
  complete project safely tucked into the (regularly backed up) repository, the potential damage of losing your disk or
  data is minimised. Setting up for development on a new machine involves simply checking out the project from the
  repository. This simplifies distributing, building, and testing the code on different platforms: on each machine, a
  single update command will ensure that the software is the current version.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Put the Mouse Down and Step Away from the Keyboard

- The next time you hit a nasty problem, do yourself a favour. Once you really understand the problem, go do something
  involving the creative side of your brain - sketch out the problem, listen to some music, or just take a walk
  outside. Sometimes the best thing you can do to solve a problem is to put the mouse down and step away from the
  keyboard.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Read Code

- We programmers are weird creatures. We love writing code. But when it comes to reading it, we usually shy away. After
  all, writing code is so much more fun, and reading code is hard - sometimes almost impossible. Reading other people's
  code is particularly hard. Not necessarily because other people's code is bad, but because they probably think and
  solve problems in a different way than you. But did you ever consider that reading someone else's code could improve
  your own?
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The next time you read some code, stop and think for a moment. Is the code easy or hard to read? If it is hard to
  read, why is that? Is the formatting poor? Is naming inconsistent or illogical? Are several concerns mixed together
  in the same piece of code? Try to learn from other people's mistakes, so that your code won't contain the same ones.
  You may receive a few surprises. For example, dependency-breaking techniques may be good for low coupling, but they
  can sometimes also make code harder to read. And what some people call elegant code, others call unreadable.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If the code is easy to read, stop to see if there is something useful you can learn from it. Maybe there's a design
  pattern in use that you don't know about, or had previously struggled to implement. Perhaps the methods are shorter
  and their names more expressive than yours.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Reading your own old code, from a project you are not currently working on, can also be an enlightening experience.
  Start with some of your oldest code and work your way forward to the present. You will probably find that it is not
  at all as easy to read as when you wrote it. Look at how you have developed your skills over the years - it can be
  truly motivating. Observe what areas of the code are hard to read, and consider whether you are still writing code in
  the same way today.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Read the Humanities

- In all but the smallest development project, people work with people. In all but the most abstracted field of
  research, people write software for people to support them in some goal of theirs. People write software with people
  for people. It's a people business.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Unfortunately, what is taught to programmers too often equips them very poorly to deal with people they work for and
  with.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Any language we use to speak to one another is not - cannot be - a serialisation format for getting a thought or idea
  or picture out of one person's head and into another's.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Our ability to understand one another at all does not arise from shared definitions, it arises from a shared
  experience, from a form of life. This may be one reason why programmers who are steeped in their problem domain tend
  to do better than those who stand apart from it.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Programmers build and use tools, we think about and create and modify and recreate tools. Tools are objects of
  interest to us. A tool becomes an invisible thing understood only in use. For users, tools only become objects of
  interest when they don't work. This difference in emphasis is worth bearing in mind whenever usability is under
  discussion.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When programmers ask users about their desires for a system, we tend to ask for definitions built out of predicates.
  This is very convenient for us. The terms in the predicates can very easily become attributes on a class or columns
  in a table. These sorts of categories are crisp, disjoint, and tidy. Unfortunately, that just isn't how people in
  general understand the world. They understand it in ways that are based on examples. Some examples, so-called
  prototypes, are better than others and so the resulting categories are fuzzy, they overlap, they can have rich
  internal structure.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Reinvent the Wheel Often

- Reinventing the wheel and getting it wrong is more valuable than nailing it first time. There are lessons learned
  from trial and error that have an emotional component to them that reading a technical book alone just cannot
  deliver.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Learned facts and book smarts are crucial, but becoming a great programmer is as much about acquiring experience as
  it is about collecting facts. Reinventing the wheel is as important to a developer's education and skill as
  weightlifting is to a body builder.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Resist the Temptation of the Singleton Pattern

- Experience shows that most singletons really do more harm than good. They hinder testability and harm
  maintainability. Unfortunately, this additional wisdom is not as widespread as it should be, and singletons continue
  to be irresistible to many programmers.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- They are worth resisting:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **The Single-Instance Requirement is Often Imagined**:

    - In many cases, it's pure speculation that no additional instances will be needed in the future. Broadcasting such
      speculative properties across an application's design is bound to cause pain at some point.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Requirements will change. Good design embraces this. Singletons don't.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Singletons Cause Implicit Dependencies Between Conceptually Independent Units of Code**:

    - This is problematic both because they are hidden and because they introduce unnecessary coupling between units.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - This code smell becomes pungent when you try to write unit tests, which depend on loose coupling and the ability
      to selectively substitute a mock implementation for a real one. Singletons prevent such straightforward mocking.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Singletons Also Carry Implicit Persistent State, Which Again Hinders Unit Testing**:

    - Unit testing depends on tests being independent of one another, so the tests can be run in any order and the
      program can be set to a known state before the execution of every unit test.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Once you have introduced singletons with mutable state, this may be hard to achieve. In addition, such globally
      accessible persistent state makes it harder to reason about the code, especially in a multithreaded environment.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Multithreading Introduces Further Pitfalls to the Singleton Pattern**:

    - As straight-forward locking on access is not very efficient, the so-called Double-Checked Locking Pattern (DCLP)
      has gained in popularity. Unfortunately, this may be a further form of fatal attraction. It turns out that in
      many languages, DCLP is not thread-safe and, even where it is, there are still opportunities to get it subtly
      wrong.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The clean-up of singletons may present a final challenge:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **There is No Support for Explicitly Killing Singletons**:

    - This can be a serious issue in some contexts - for example, in a plug-in architecture where a plug-in can only be
      safely unloaded after all its objects have been cleaned up.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **There is No Order to the Implicit Clean-Up of Singletons at Program Exit**:

    - This can be troublesome for applications that contain singletons with interdependencies. When shutting down such
      applications, one singleton may access another that has already been destroyed.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Some of these shortcomings can be overcome by introducing additional mechanisms. However, this comes at the cost of
  additional complexity in code that could have been avoided by choosing an alternative design.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Restrict your use of the Singleton pattern to the classes that truly must never be instantiated more than once.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Simplicity Comes from Reduction

- It's natural, particularly when you're in a rush, to just want to make the most minimal changes to an existing block
  of code, even if it is awful. Most programmers will preserve bad code, fearing that starting anew will require
  significantly more effort than just going back to the beginning. That can be true for code that is close to working,
  but there is just some code that is beyond all help.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The best approach to fixing bad code is to flip into a mode where the code is mercilessly refactored, shifted around,
  or deleted.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Start from Yes

- Sometimes the other person will simply have an idea that you find incompatible with your view of the product. You
  will likely find it's usually helpful to turn that "Why?" on yourself. Sometimes the act of voicing the reason will
  make it clear that your first reaction doesn't make sense. If not, you might need to kick it up a notch and bring in
  other key decision makers. Remember, the goal of all of this is to say yes to the other person and try to make it
  work, not just for him but for you and your team as well.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If you can voice a compelling explanation as to why the feature request is incompatible with the existing product,
  then you are likely to have a productive conversation about whether you are building the right product. Regardless of
  how that conversation concludes, everyone will focus more sharply on what the product is, and what it is not.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Starting from yes means working with your colleagues, not against them.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Step Back and Automate, Automate, Automate

- Why do people do the same task over and over instead of stepping back and taking the time to automate it? Here are a
  few common misconceptions:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Automation is Only For Testing**:

    - Repetitive tasks abound in any project: version control, compiling, building JAR files, documentation generation,
      deployment, and reporting. For many of these tasks, the script is mightier than the mouse. Executing tedious
      tasks becomes faster and more reliable.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **I Have an IDE, So I Don't Have to Automate**:

    - Modern IDEs have thousands of potential settings, and it is essentially impossible to ensure that all team
      members have identical configurations. Build automation systems such as Ant or Autotools give you control and
      repeatability.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **I Need to Learn Exotic Tools in Order to Automate**:

    - You can go a long way with a decent shell language (such as *bash* or PowerShell) and a build automation system.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - If you need to interact with websites, use a tool such as iMacros or Selenium.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **I Can't Automate This Task Because I Can't Deal With These File Formats**:

    - If a part of your process requires Word documents, spreadsheets, or images, it may be challenging to automate it.
      Often, a slight tweak in the process can yield good results with a dramatic reduction in tediousness, plain text,
      comma-separated values, XML files might be better alternatives to the files you may be using that would be
      difficult to automate.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **I Don't Have Time to Figure it Out**:

    - You don't have to learn all of *bash* or Ant to get started. Learn as you go. When you have a task that you think
      can and should be automated, learn just enough about your tools to do it.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Take Advantage of Code Analysis Tools

- Don't let testing be the end of your quality assurance - take advantage of analysis tools, and don't be afraid to roll
  your own.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Test for Required Behaviour, Not Incidental Behaviour

- When tests are hardwired to implementation incidentals, changes to the implementation that are actually compatible
  with the required behaviour may cause tests to fail, likely making them very brittle.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Overspecified tests are often a problem with whitebox approaches to unit testing. Whitebox tests use the structure of
  the code to determine the test cases needed. The typical failure mode of whitebox testing is that the tests end up
  asserting that the code does what the code does. Simply restating what is already obvious from the code adds no value
  and leads to a false sense of progress and security.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- To be effective, tests need to state contractual obligations rather than parrot implementations. They need to take a
  blackbox view of the units under test, sketching out the interface contracts in executable form. Therefore, align
  tested behaviour with required behaviour.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Test Precisely and Concretely

- In specifying behaviour, tests should not simply be accurate: they must also be precise.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Test While You Sleep (And Over Weekends)

- Are you constantly finding it difficult to get enough computing power during the work day? If so, what are your test
  servers doing outside of normal work hours? More often than not, the test servers are idling overnight and over the
  week end. You can use this to your advantage:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Have You Been Guilty of Committing a Change Without Running All the Tests?**:

    - One of the main reasons programmers don't run test suites before committing code is because of the length of time
      they may take. When deadlines are looming and push comes to shove, humans naturally start cutting corners.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - One way to address this is to break down your large test suite into two or more profiles. A smaller, mandatory
      test profile that is quick to run will help to ensure that tests are run before each commit. All of the test
      profiles (including the mandatory profile - just to be sure) can be automated to run overnight, ready to report
      their results in the morning.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Have You Had Enough Opportunity to Test the Stability of Your Product?**:

    - Longer-running tests are vital for identifying memory leaks and other stability issues. They are seldom run
      during the day, as it will tie up time and resources. You could automate a soak test to be run during the night,
      and a bit longer over the weekend.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Are You Getting Quality Time on Your Performance Testing Environment?**:

    - It's a common occurrence for teams/colleagues to need their environments during the day. The servers and the
      network are not as busy during the night or over the weekend. It's an ideal time to run some quality performance
      tests.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Are There Too Many Permutations to Test Manually?**:

    - Manually testing all of of an application's possible permutations is very time consuming and most likely done
      close to a release due to resource pressure. Alas, it may be too late in the cycle to catch certain nasty bugs.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Automated tests run during the night or over weekends will ensure that all the application's possible
      permutations are tested more often.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Testing is the Engineering Rigour of Software Development

- Testing takes time, just like structural analysis takes time in "hard" engineering. Both activities ensure the
  quality of the end product. It's time for software developers to take up the mantle of responsibility for what they
  produce. Testing alone isn't sufficient, but it is necessary. Testing is the engineering rigour of software
  development.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Boy Scout Rule

- Always check a module in cleaner than when you checked it out. Regardless of who the original author was, always make
  some effort, no matter how small, to improve the module.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Golden Rule of API Design

- It's not enough to write tests for an API you develop; you have to write unit tests for code that uses your API. When
  you follow this rule, you learn first-hand the hurdles that your users will have to overcome when they try to test
  their code independently.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Guru Myth

- Consider the best programmer you've ever met: at one point, that person knew less about software than you do now. If
  someone seems like a guru, it's because of years dedicated to learning and refining thought processes. A "guru" is
  simply a smart person with relentless curiosity.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Removing the guru myth also means removing a perceived barrier to improvement. Instead of a magical barrier, you can
  see a continuum along which you can advance.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- One of software's biggest obstacles is smart people who purposefully propagate the guru myth. This might be done out
  of ego, or as a strategy to increase one's value as perceived by a client or employer. Ironically, this attitude can
  make smart people less valuable, since they don't contribute to the growth of their peers. We don't need gurus. We
  need experts willing to develop other experts in their field. There is room for all of us.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Linker Is Not a Magical Program

- Although it is not always immediately obvious why you get a particular linker message, there is nothing magical about
  linkers. The mechanics are straightforward; it's the details you have to figure out in each case.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Longevity of Interim Solutions

- In most systems and teams, you will find some software that is somewhat segregated from the system, that is
  considered a draft to be changed sometime, that does not follow the standards and guidelines that shaped the rest of
  the code. Inevitably, you will hear developers complaining about these. The reasons for their creation are many and
  varied, but the key to an interim solution's success is simple: it is useful.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Interim solutions, however, acquire inertia (or momentum, depending on your point of view). Because they are there,
  ultimately useful and widely accepted, there is no immediate need to do anything else.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You will create many solutions; some of them will be interim, most of them will be useful. The best way to overcome
  interim solutions is to make them superfluous, to provide a more elegant and useful solution. May you be granted the
  serenity to accept the things you cannot change, the courage to change the things you can, and the wisdom to know the
  difference.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Professional Programmer

- The single most important trait of a professional programmer is personal responsibility. Professional programmers
  take responsibility for their career, their estimates, their schedule commitments, their mistakes, and their
  workmanship.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A professional programmer does not pass that responsibility off on others:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **If You are a Professional, Then You Are Responsible For Your Own Career**:

    - You are responsible for reading and learning. You are responsible for staying up to date with the industry and
      the technology.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Professionals Take Responsible for the Code They Write**:

    - They do not release code unless they know it works. How can you possibly consider yourself a professional if you
      are willing to release code that you are not sure of?
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - Professional programmers expect QA to find nothing because they don't release their code until they've thoroughly
      tested it. Of course, QA will find some problems, because no one is perfect. But as professionals, our attitude
      must be that we will leave nothing for QA to find.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Professionals are Team Players**:

    - They take responsibility for the output of the whole team, not just their own work. They help one another, teach
      one another, learn from one another, and even cover for one another when necessary.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - When one teammate falls down, the others step in, knowing that one day they'll be the ones to need cover.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Professionals Do Not Tolerate Big Bug Lists**:

    - A huge bug list is sloppy. Systems with thousands of issues in the issue-tracking database are tragedies of
      carelessness.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - **Professionals Do Not Make a Mess**:

    - They take pride in their workmanship. They keep their code clean, well structured, and easy to read. They follow
      agreed-upon standards and best practices.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

    - They do not abandon their principles when deadlines loom.
      [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Road to Performance is Littered with Dirty Code Bombs

- More often than not, performance tuning a system requires you to alter code. When we need to alter code, every chunk
  that is overly complex or highly coupled is a dirty code bomb lying in wait to derail the effort. The first casualty
  of dirty code will be your schedule. If the way forward is smooth, it will be easy to predict when you'll finish.
  Unexpected encounters with dirty code will make it very difficult to make a sane prediction.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- In fact, we have many ways of measuring and controlling the degree and depth of coupling and complexity of our code.
  Software metrics can be used to count the occurrences of specific features in our code. The values of these counts do
  correlate with code quality. Two of a number of metrics that measure coupling are fan-in and fan-out:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Consider fan-out for classes: it is defined as the number of classes referenced either directly or indirectly from
    a class of interest. You can think of this as a count of all the classes that must be compiled before your class
    can be compiled.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Fan-in, on the other hand, is a count of all classes that depend upon the class of interest. Knowing fan-out and
    fan-in, we can calculate an instability factor using `I = fanOut / (fanIn + fanOut)`.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - As I approaches 0, the package becomes more stable. As `I` approaches 1, the package becomes unstable. Packages
    that are stable are low-risk targets for recoding, whereas unstable packages are more likely to be filled with
    dirty code bombs.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When using metrics, one must remember that they are only rules of thumb. Based purely on math, we can see that
  increasing `fanIn` without changing `fanOut` will move `I` closer to 0. There is, however, a downside to a very large
  fan-in value: these classes will be more difficult to alter without breaking dependents. Also, without addressing
  fan-out, you're not really reducing your risks, so some balance must be applied.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Single Responsibility Principle

- A subsystem, module, class, or even a function, should not have more than one reason to change.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Good system design means that we separate the system into components that can be independently deployed. Independent
  deployment means that if we change one component, we do not have to redeploy any of the others.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Each class can be placed in a component of its own. Or rather, all the reporting classes can go into the reporting
  component. All the database-related classes can go into the repository component. And all the business rules can go
  into the business rule component.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### The Unix Tools Are Your Friends

- The small-is-beautiful provenance and open source implementations of the Unix tools make them ubiquitously available,
  even on resource-constrained platforms.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If none of the available tools matches your needs, it's very easy to extend the world of the Unix tools. Just write a
  program (in any language you fancy) that plays by a few simple rules: your program should perform just a single task;
  it should read data as text lines from its standard input; and it should display its results unadorned by headers and
  other noise on its standard output. Parameters affecting the tool's operation are given in the command line.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Thinking in States

- In most real-world situations, people's relaxed attitude toward state is not an issue. Unfortunately, however, many
  programmers are quite vague about state, too - and that is a problem.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- But how do you begin thinking in states? Extracting expressions to meaningful methods is a very good start, but it is
  just a start. The foundation is to understand state machines.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- State machines are not particularly hard. Visualise them to make them simple to understand and easy to talk about.
  Test-drive your code to unravel valid and invalid states and transitions and to keep them correct. Study the State
  pattern. When you feel comfortable, read up on Design by Contract. It helps you ensure a valid state by validating
  incoming data and the object itself on entry and exit of each public method.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Two Heads Are Often Better Than One

- This "lone wolf" approach to programming has been giving way to a more collaborative approach. This approach has
  developers working more closely with one another and also with non-developers - business and systems analysts, quality
  assurance professionals, and users.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Collaboration is not about asking and answering questions or sitting in meetings. It's about rolling up your sleeves
  with someone else to jointly attack work.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When pairing, we each bring our collective programming experiences domain as well as technical - to the problem at
  hand and can bring unique insight and experience into writing software effectively and efficiently. Even in cases of
  extreme imbalance in domain or technical knowledge, the more experienced participant invariably learns something from
  the other - perhaps a new keyboard shortcut, or exposure to a new tool or library. For the less-experienced member of
  the pair, this is a great way to get up to speed.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Two Wrongs Can Make a Right (And Are Difficult to Fix)

- Single wrongs can be easy to spot and easy to fix. It is the problems with multiple causes, needing multiple changes,
  that are harder to resolve. In part, this is because easy problems are so easily fixed that people tend to fix them
  relatively quickly and store up the more difficult problems for a later date.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Ubuntu Coding for Your Friends

- Creating software is a technical exercise mixed into a social exercise. We just need to lift our heads more often to
  realise that we are not working in isolation, and we have shared responsibility for increasing the probability of
  success for everyone, not just the development team.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You can write good-quality code in isolation, all the while lost in self. From one perspective, that is an egocentric
  approach (not ego as in arrogant, but ego as in personal).
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The quality of the code I write affects the quality of the code you write. What if my code is of poor quality? Even
  if you write very clean code, it is at the points where you use my code that your code quality will degrade to close
  to the quality of my code. You can apply many patterns and techniques to limit the damage, but the damage has already
  been done. I have caused you to do more than what you needed to do, simply because I did not think about you when I
  was living in my moment.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Use the Right Algorithm and Data Structure

- Programmers should not reinvent the wheel, and should use existing libraries where possible. Above all, however,
  programmers should know when, what, and how to reuse. To do that, they should have knowledge of the problem domain
  and of algorithms and data structures.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Verbose Logging Will Disturb Your Sleep

- Too much logging can be as useless as none at all.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- For many systems, the first indication that something is wrong is a log message being written to some log. Mostly,
  this will be the error log. So do yourself a favour: make sure from day one that if something is logged in the error
  log, you're willing to have someone call and wake you in the middle of the night about it. If you can simulate load
  on your system during system testing, looking at a noise-free error log is also a good first indication that your
  system is reasonably robust - or an early warning if it's not.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- A cluttered log is an indication that the system will be hard to control once it reaches production. If you don't
  expect anything to show up in the error log, it will be much easier to know what to do when something does show up.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### WET Dilutes Performance Bottlenecks

- The antithesis of DRY is WET (Write Every Time). Your code is WET when knowledge is codified in several different
  implementations. The performance implications of DRY versus WET become very clear when you consider their numerous
  effects on a performance profile. Following DRY helps find and repair a performance bottleneck that would have been
  more difficult to find had the code been WET.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### When Programmers and Testers Collaborate

- When testers and programmers start to collaborate, there is less time spent sending bugs back and forth through the
  defect tracking system. Less time is wasted trying to figure out whether something is really a bug or a new feature,
  and more time is spent developing good software to meet customer expectations. There are many opportunities for
  starting collaboration before coding even begins.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- When testers stop thinking that their only job is to break the software and find bugs in the programmers' code,
  programmers stop thinking that testers are "out to get them," and are more open to collaboration. When programmers
  start realising that they are responsible for building quality into their code, testability of the code is a natural
  by-product, and the team can automate more of the regression tests together. The magic of successful teamwork begins.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Write Code As If You Had to Support It for the Rest of Your Life

- There is a simple way to adjust your attitude and always be driven to deliver the best quality products: "write code
  as if you had to support if for the rest of your life."
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If you accept this notion, many wonderful things will happen. If you were to accept that any of your previous or
  current employers had the right to call you in the middle of the night, asking you to explain the choices you made
  while writing a given method, you would gradually improve toward becoming an expert programmer. You would naturally
  want to come up with better variable and method names. You would stay away from blocks of code comprising hundreds of
  lines. You would seek, learn, and use design patterns. You would write comments, test your code, and refactor
  continually. Supporting all the code you'd ever written for the rest of your life should also be a scalable
  endeavour. You would therefore have no choice but to become better, smarter, and more efficient.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- If you reflect on it, the code you wrote many years ago still influences your career, whether you like it or not. You
  leave a trail of your knowledge, attitude, tenacity, professionalism, level of commitment, and degree of enjoyment
  with every method, class, and module you design and write. People will form opinions about you based on the code that
  they see. If those opinions are constantly negative, you will get less from your career than you hoped. Take care of
  your career, of your clients, and of your users with every line of code - write code as if you had to support it for
  the rest of your life.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Write Small Functions Using Examples

- Using domain-inspired types can often make our functions much smaller, instead of relying on native types. One way to
  find out what those types should be is to find the examples to check in problem domain terms, before writing the
  function.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Write Tests for People

- Good tests act as documentation for the code they are testing. They describe how the code works. For each usage
  scenario, the test(s):
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Describe the context, starting point, or preconditions that must be satisfied.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Illustrate how the software is invoked.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Describe the expected results or postconditions to be verified.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Different usage scenarios will have slightly different versions of each of these. The person trying to understand
  your code should be able to look at a few tests, and by comparing these three parts of the tests in question, be able
  to see what causes the software to behave differently. Each test should clearly illustrate the cause-and-effect
  relationship among these three parts.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Between them, the names of the test class and class method should include at least the starting point and how the
  software is being invoked. This allows the test coverage to be verified via a quick scan of the method names. It can
  also be useful to include the expected results in the test method names as long as this doesn't cause the names to be
  too long to see or read.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### You Gotta Care About the Code

- Good code doesn't pop out of thin air. It isn't something that happens by luck when the planets align. To get good
  code, you have to work at it. Hard. And you'll only get good code if you actually care about good code.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Good programming is not born from mere technical competence. Highly intellectual programmers who can write terrible
  code. Mediocre programmers can write very simple code, but write elegant and expressive programs.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- The real difference between adequate programmers and great programmers is this: attitude. Good programming lies in
  taking a professional approach, and wanting to write the best software you can, within the real-world constraints and
  pressures of the software factory.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- To be an excellent programmer, you have to rise above good intentions, and actually care about the code - foster
  positive perspectives and develop healthy attitudes. Great code is carefully crafted by master artisans, not
  thoughtlessly hacked out by sloppy programmers or erected mysteriously by self-professed coding gurus.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- You want to write good code. You want to be a good programmer. So, you care about the code:
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - In any coding situation, you refuse to hack something that only seems to work. You strive to craft elegant code
    that is clearly correct (and has good tests to show that it is correct).
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - You write code that is discoverable (that other programmers can easily pick up and understand), that is
    maintainable (that you, or other programmers, will be easily able to modify in the future), and that is correct
    (you take all steps possible to determine that you have solved the problem, not just made it look like the program
    works).
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - You work well alongside other programmers You consider other programmers and construct code that others can read.
    You want the team to write the best software possible, rather than to make yourself look clever.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - Any time you touch a piece of code, you strive to leave it better than you found it.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

  - You care about code and about programming, so you are constantly learning new languages, idioms, and techniques.
    You apply them only when appropriate.
    [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

### Your Customers Do Not Mean What They Say

- Customers are always more than happy to say what they want - usually in great detail. The problem is that customers
  don't always tell you the whole truth. They generally don't lie, but they speak in customer speak, not developer
  speak. They use their terms and their contexts. They leave out significant details. They make assumptions that you've
  been at their company for 20 years, just like they have. This is compounded by the fact that many customers don't
  actually know what they want in the first place.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Challenge your customers early, and challenge them often. Don't simply restate what they told you they wanted in
  their words.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Discuss topics numerous times with your customers before you decide that you understand what they need. Try restating
  the problem two or three times with them. Talk to them about the things that happen just before or just after the
  topic you're talking about to get better context. If at all possible, have multiple people tell you about the same
  topic in separate conversations. They will almost always tell you different stories, which will uncover separate yet
  related facts.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

- Use visual aids in your conversations. This could be as simple as using a whiteboard in a meeting, as easy as
  creating a visual mock-up early in the design phase, or as complex as crafting a functional prototype.
  [O'Reilly: 97 Things Every Programmer Should Know](#oreilly-97-things-every-programmer-should-know)

</details>

## *bash* Cookbook

<details open>

<summary>Click to expand/minimise the full contents of this book.</summary>

### Preface

- Every modern operating system has at least one shell, and some have many. Some shells are command lineoriented, such
  as the shell discussed in this book. Others are graphical, like Windows Explorer or the Macintosh Finder.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- A shell script can save you time and effort, or facilitate consistency and repeatability for some important task.
  Even using an alias to change or shorten the name of a command you use often can have a significant effect.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- There is also sometimes a choice between a clever way to write some code, and a readable way. The readable way is the
  only smart choice.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Who Should Read This Book

- This book is for anyone who uses a Unix or Linux system, as well as system administrators who may use several systems
  on any given day. With it, you will be able to create scripts that allow you to accomplish more, in less time, more
  easily, consistently, and repeatable than ever before.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Ideal readers include:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - New Unix or Linux users who don't know much about the shell, but want to do more than point and click.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Experienced Unix or Linux users and system administrators looking for quick answers to shell scripting questions.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Programmers who work in a Unix or Linux (or even Windows) environment and want to be more productive.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - New Unix or Linux sysadmins, or those coming from a Windows environment who need to come up to speed quickly.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Experienced Windows users and sysadmins who want a more powerful scripting environment.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- This book assumes you have access to a Unix or Linux system and are familiar with logging in, typing basic commands,
  and using a text editor. You do not have to be root to use the vast majority of the recipes, though there are a few,
  particularly dealing with installing bash, where root access will be needed.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### About This Book

- This book covers *bash*, the GNU Bourne Again Shell, which is a member of the family of shells that includes the
  original Bourne shell, *sh*, the Korn shell, ksh, and the public domain Korn shell, pdksh. While these and other
  shells such as *dash* and *zsh* are not specifically covered, odds are that most of the scripts will work pretty well
  with them.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- A great part of the Unix philosophy is to build simple tools that do one thing well, then combine them as needed.
  This combination of tools is often accomplished via a shell script because these commands, called pipelines, can be
  long or difficult to remember and type. Where appropriate, the book will cover the use of many of these tools in the
  context of the shell script as the glue that holds the pieces together to achieve the goal.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

##### GNU Software

- *bash* and many of the other tools discussed in this book are part of the GNU Project. GNU is a recursive acronym for
  "GNU's Not Unix," and the project dates back to 1984. Its goal is to develop a free (as in freedom) Unix-like
  operating system.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

##### A Note About Code Examples

- Examples with a dollar symbol at the start of a line indicates it is a *bash* shell prompt. Each line is a user
  input. The prompt is printed by the shell; you type the remainder of the line. Similarly, the last line in such an
  example is often a prompt (the $ again), to show that the command has ended execution and control has returned to
  the shell.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The hash sign is used as a comment as well as indicating being logged in as root.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

##### Useless Use of cat

- The following is a useless use of cat:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cat "<file>" | grep "<foo>"
  ```

- The following is a more efficient use of searching for text in a file, as cat incurs system overhead, since it runs
  in a subprocess.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  grep "<foo>" "<file>"
  ```

- Sometimes unnecessarily using cat actually does serve a purpose. It might be a placeholder to demonstrate a fragment
  of a pipeline, with other commands later replacing it. Or it might be that placing the file near the left side of the
  code draws the eye to it more clearly than if it were obscured after any additional code.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- As a result of the fact processors aren't getting any slower, then use cat if you would like to use it, as long as it
  doesn't add any additional code bloat or complexity to scripts.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

##### A Note About Perl

- Perl is seldom used in the book, although there a few cases where it makes sense for code examples.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Perl solutions are generally much larger, with significantly more overhead than bash.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Shell scripting is basically glue for combining Unix programs, whereas Perl incorporates much of the functionality of
  the external Unix programs into the language itself. This makes it more efficient and in some ways more portable, at
  the expense of being different and making it harder to efficiently run any external programs you still need.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The choice of which tool to use often has more to do with familiarity than any other reason. The bottom line is
  always get the work done; the choice of tools is secondary.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

<!-- #### Conventions Used in This Book

- The following typographical conventions are used in the book:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Plain Text: Indicates menu titles, menu options, menu buttons, and keyboard accelerators (such as Alt and Ctrl).
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - *Italic*: Indicates new terms, URLs, email addresses, filenames, file extensions, path names, directories, and Unix
    utilities.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - <pre>Constant width</pre>: Indicates commands, options, switches, variables, attributes, keys, functions, types,
    classes, namespaces, methods, modules, properties, parameters, values, objects, events, event handlers, XML tags,
    HTML tags, macros, the contents of files, and the output from commands.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - **<pre>Constant width</pre>**: Shows commands or other text that should be typed literally by the user.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - *<pre>Constant width</pre>*: Shows text that should be replaced with user-supplied values.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Beginning *bash*

- The Unix operating system popularised the notion of separating the shell (the part of the system that lets you type
  commands) from everything else: the input/output system, the scheduler, memory management, and all of the other
  things the operating system takes care of for you (and that most users don't want to care about). The shell was just
  one more program; it was a program whose job was executing other programs on behalf of users.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Modern shells are very convenient. For example, they remember commands that you've typed, and let you reuse those
  commands. Modern shells also let you edit those commands, so they don't have to be the same each time. And modern
  shells let you define your own command abbreviations, shortcuts, and other features. For an experienced user, typing
  commands (e.g., with shorthand, shortcuts, and command completion) is a lot more efficient and effective than
  dragging things around in a fancy windowed interface.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Beyond simple convenience, shells are programmable. There are many sequences of commands that you type again and
  again. A shell is also a programming language that's specially designed to work with your computer system's commands.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Whenever you find yourself doing a task repeatedly, you should try to automate it by writing a shell script. There
  are more powerful scripting languages, like Perl, Python, and Ruby, but the Unix shell (whatever flavour of shell
  you're using) is a great place to start.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Why *bash*?

- *bash* is everywhere. It may not be the newest, and it's arguably not the fanciest or the most powerful (though if
  not, it comes close), nor is it the only shell that's distributed as open source software - but it is ubiquitous.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- *bash* is commonly the default user shell on every Linux distribution. In the rare cases where *bash* doesn't ship
  with the operating system, it's easy to install. It's even available for Windows, via Cygwin and also the new Linux
  Subsystem (Ubuntu). *bash* is both a powerful programming language and a good user interface, and you won't find
  yourself sacrificing keyboard shortcuts to get elaborate programming features.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- You can't possibly go wrong by learning *bash*. The most common default shells are the old Bourne shell and *bash*,
  which is mostly Bourne shellcompatible. One of these shells is certainly present on any modern, major Unix or
  Unix-like operating system.
  [O'Reilly: bash Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- There are many good alternatives, and you may find one you like better - though it probably won't be as ubiquitous as
  *bash*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### The *bash* Shell

- *bash* is a shell: a command interpreter. The main purpose of *bash* (or of any shell) is to allow you to interact
  with the computer's operating system so that you can accomplish whatever you need to do.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Showing Where You Are

- *pwd* stands for print working directory and takes two options. *--logical* displays your logical path and is the
  default. *--physical* displays your physical location, which may differ from your logical path if you have followed a
  symbolic link. Similarly, the cd command also provides *--physical* and *--logical* switches:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  bash-4.3$ pwd
  /tmp/dir2

  bash-4.3$ pwd --logical
  /tmp/dir2

  bash-4.3$ pwd --physical
  /tmp/dir1
  ```

#### Finding & Running Commands

- Try the *type*, *which*, *apropos*, *locate*, *slocate*, *find*, and *ls* commands when you need to find and run a
  particular command under *bash*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- **Finding Commands**:

  - *bash* keeps a list of directories in which it should look for commands in an environment variable called PATH. The
    *bash* builtin *type* command searches your environment (including aliases, keywords, functions, builtins,
    directories in $PATH, and the command hash table) for executable commands matching its arguments and displays the
    type and location of any matches.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - The *which* command is similar to *type* but only searches your $PATH (and *csh* aliases). It may vary from system
    to system (it's usually a csh shell script on BSD, but a binary on Linux). Use these commands when you know the
    name of a command and need to know exactly where it's located, or to see if it's on this computer.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- **Assistance with Executing Commands**:

  - Almost all commands come with some form of help on how to use them. Usually there is online documentation called
    manpages, where *man* is short for manual. These are accessed using the man command. Many programs also have a
    built-in help facility, accessed by providing a "help me" argument such as *-h* or *--help*. Some programs,
    especially on other operating systems, will give you help if you don't give them arguments. Some Unix commands will
    also do that, but a great many of them will not. This is due to the way that Unix commands fit together into
    something called pipelines.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - If you don't know or can't remember the name of the command you need? *apropos* searches manpage names and
    descriptions for regular expressions supplied as arguments. This is incredibly useful when you don't remember the
    name of the command you need.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- **Finding Files**:

  - *locate* and *slocate* consult database files about the system (usually compiled and updated by a job run from the
    scheduler system *cron*) to find files or commands almost instantly. The location of the actual database files, what
    is indexed therein, and how often it is checked may vary from system to system.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - *slocate* (secure locate) stores permission information (in addition to filenames and paths) so that it will not
    list programs to which the user does not have access.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - On most Linux systems, *locate* is a symbolic link to *slocate*; other systems may have separate programs, or may
    not have slocate at all.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Try using *ls*. If the command you wish to run is in your current directory, you must prefix it with a *./* since the
  current working directory is usually not in your $PATH for security reasons.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Getting Information About Files

- Use the *ls*, *stat*, *file*, or *find* commands to get more information about a file, such as what it is, who owns
  it, if it's executable, how many hard links it has, or when it was last accessed or changed.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Using Shell Quoting

- Enclose a string in single quotes unless it contains elements that you want the shell to interpolate. Unquoted text
  and even text enclosed in double quotes is subject to shell expansion and substitution.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- You can't embed a single quote inside single quotes, even if using a backslash, since nothing (not even the
  backslash) is interpolated inside single quotes. But you can work around that by using double quotes with escapes, or
  by escaping a single quote outside of surrounding single quotes.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Determining if You Are Running Interactively

- Use the *case* statement if you have some code you want to run only if you are (or are not) running interactively.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  case "$-" in
  *i*) # Code for interactive shell here
  ;;
  *) # Code for non-interactive shell here
  ;;
  esac
  ```

- *\$-* is a string listing of all the current shell option flags. It will contain *i* if the shell is interactive.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- You may also see code like the following, but the previous example is preferred.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  if [ -n "$PS1" ]; then
    echo This shell is interactive
  else
    echo This shell is not interactive
  fi
  ```

### Standard Output

- No software is worth anything if there is no output of some sort, but I/O has long been one of the nastier areas of
  computing.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- One of the most important ideas behind the Unix operating system was that everything looked like a file (an ordered
  sequence of bytes). The operating system was responsible for this magic. It didn't matter whether you were writing to
  a file on the disk, the terminal, a tape drive, a memory stick, or something else; your program only needed to know
  how to write to a file, and the operating system would take it from there. That approach greatly simplified the
  problem.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- When you run a program, you still have to connect it to output files and input files. That task doesn't go away, but
  the shell makes it trivially easy. A command as simple as the example below reads its input from `input_file` and
  sends its output to `output_file`. If you omit the `> output_file`, the output goes to your terminal window. If you
  omit the `< input_file`, the program takes its input from the keyboard. The program literally doesn't know where its
  output is going, or where its input is coming from.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  do_something < input_file > output_file
  ```

#### Writing Output to the Terminal/Window

- The *echo* command parses all the arguments on the *echo* command line. The shell is parsing the arguments on the
  *echo* command line (like it does for every other command line). This means that it does all its substitutions,
  wildcard matching, and other things before handing the arguments off to *echo*. Since they are parsed as arguments,
  the spacing between arguments is ignored.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo this   was   very   widely   spaced
  this was very widely spaced
  ```

- Normally the fact that the shell is very forgiving about whitespace between arguments is a helpful feature.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Writing Output but Preserving Space

- Enclosing the string in quotes as a parameter for the *echo* command will help preserve spacing.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo "this was very widely spaced"
  this was very widely spaced

  $ echo 'this was very widely spaced'
  this was very widely spaced
  ```

- Since the words are enclosed in quotes, they form a single argument to the *echo* command. That argument is a string,
  and the shell doesn't need to interfere with the contents of the string. In fact, by using single quotes (*''*) you
  explicitly tell the shell not to interfere with the string at all. If you use double quotes (*""*), some shell
  substitutions do take place (variable, arithmetic, and tilde expansions and command substitutions), but since we have
  none in the example, the shell has nothing to change. When in doubt, use the single quotes.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Writing Output with More Formatting Control

- Use the *printf* builtin command when you want more control over the formatting and placement of output.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ printf '%s = %d\n' Lines $LINES
  Lines = 24

  $ printf '%-10.10s = %4.2f\n' 'Gigahertz' 1.92735
  Gigahertz = 1.93
  ```

- The *printf* builtin command behaves like the C language library call, where the first argument is the format control
  string and the successive arguments are formatted according to the format specifications (*%*).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The numbers between the *%* and the format type (*s* or *f* in our example) provide additional formatting details.
  For the floating-point type (*f*), the first number (*4* in the *4.2* specifier) is the width of the entire field.
  The second number (*2*) is how many digits should be printed to the right of the decimal point. Note that it rounds
  the answer.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- For a string, the first number is the maximum field width, and the second is the number of bytes to be printed. The
  string will be truncated (if longer than *max*) or blank padded (if less than min) as needed. When the *max* and*min*
  specifiers are the same, then the string is guaranteed to be that length. The negative sign on the specifier means to
  left-align the string (within its field width). Without the minus sign, the string would right-justify, thus:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ printf '%10.10s = %4.2f\n' 'Gigahertz' 1.92735
    Gigahertz = 1.93
  ```

#### Writing Output Without the Newline

- Exclude the *\n* when using *printf* to produce an output without the default newline:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ printf "%s %s" next prompt
  next prompt$
  ```

- With *echo*, use the *-n* option:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo -n prompt
  prompt$
  ```

- Because of the powerful and flexible formatting that *printf* provides, and because it is a builtin with very little
  overhead to invoke (unlike in other shells or older versions of *bash*, where *printf* was a standalone executable),
  *printf* will be used for many examples throughout this book.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Appending Rather than Clobbering Output

- The double greater-than sign (*>>*) is a *bash* redirector that means append the output:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ls > /tmp/ls.out
  $ cd ../elsewhere
  $ ls >> /tmp/ls.out
  $ cd ../another/dir
  $ ls >> /tmp/ls.out
  $
  ```

- The first line includes a redirect that truncates the file if it exists and starts with a clean (empty) file, filling
  it with the output from the *ls* command. The second and third invocations of *ls* use the double greater-than sign
  (>>) to indicate appending to, rather than replacing the contents of, the output file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Using Just the Beginning of End of a File

- Use the *head* or *tail* command when you need to display just the beginning or end of a file. By default, *head*
  will output the first 10 lines and *tail* will output the last 10 lines of the given file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Throwing Output Away

- Sometimes you don't want to save the output into a file; in fact, sometimes you don't even want to see it at all.
  Unix and Linux systems have a special device that isn't real hardware at all, just a bit bucket where we can dump
  unwanted data. It's called */dev/null* and is perfect for these situations. Any data written there is simply thrown
  away, so it takes up no disk space. Redirection makes it easy.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  example_command 2> /dev/null

  example_command > /dev/null 2>&1
  ```

#### Saving or Grouping Output from Several Commands

- You want to capture the output with a redirect, but you're typing several commands on one line. The final redirect
  applies only to the last command, the last ls on that line. All the other output appears on the screen (i.e., does
  not get redirected).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  pwd; ls; cd ../elsewhere; pwd; ls > /tmp/all.out
  ```

- Use braces *({ })* to group these commands together; then redirection applies to the output from all commands in the
  group.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  { pwd; ls; cd ../elsewhere; pwd; ls; } > /tmp/all.out

  (pwd; ls; cd ../elsewhere; pwd; ls) > /tmp/all.out
  ```

- The curly braces in the previous example are actually reserved words, so they must be surrounded by whitespace. Also,
  the trailing semicolon is required before the closing brace.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The curly braces are just a way to group several commands together, more like a shorthand for our redirecting, so
  that we don't have to redirect each command separately. Commands enclosed in parentheses, however, run in another
  instance of the shell, a child of the current shell called a subshell.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The subshell is almost identical to the current shell's environment - i.e., variables, including *\$PATH*, are all the
  same, but traps are handled differently. Because a subshell is used to execute the cd commands, when the subshell
  exits, your main shell remains where it started. That is, its current directory hasn't moved, and its variables
  haven't changed.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- With the curly braces used for grouping, you end up in the new directory (*../elsewhere* in the example above). Any
  other changes that you make (variable assignments, for example) will be made to your current shell instance. While
  both approaches result in the same output, they leave you in very different places.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Connecting Two Programs by Using Output as Input

- Using the pipe symbol means we don't have to invent a temporary filename, remember it, and remember to delete it.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Commands run connected by pipes are run in separate processes. While such a subtlety can often be ignored, there are
  a few times when the implications of this are important.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Saving a Copy of Output Even While Using It as Input

- Using the *tee* command to split the output into two identical streams, one that is written to a file and the other
  that is written to standard output.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  find / -name '*.c' -print | tee /tmp/all.my.sources
  ```

- In the previous example we did not redirect standard error at all. This means that any errors, like you might expect
  will be printed to the screen but won't show up in the tee file. This is addressed in the example below. It won't be
  neatly separated, but it will be captured.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  find / -name '*.c' -print 2>&1 | tee /tmp/all.my.sources
  ```

#### Keeping Files Safe from Accidental Overwriting

- The *noclobber* option tells bash not to overwrite any existing files when you redirect output. If the file to which
  you redirect output doesn't (yet) exist, everything works as normal, with bash creating the file as it opens it for
  output. If the file already exists, however, you will get an error message.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # Disabling the noclobber option (just in case it has already been set).
  $ set +o noclobber

  # Creating the file.
  $ echo something > my.file

  # Overwriting the file.
  $ echo some more > my.file

  # Enabling the noclobber option.
  $ set -o noclobber

  # Attempting to overwrite the file.
  $ echo something > my.file
  bash: my.file: cannot overwrite existing file

  # Appending the file's contents.
  $ echo some more >> my.file
  ```

- The *noclobber* option only refers to the shell's clobbering of a file when redirecting output. It will not stop
  other file manipulating actions of other programs from clobbering files.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Clobbering a File on Purpose

- Use *>|* to redirect your output. Even if noclobber is set, bash ignores its setting and overwrites the file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # Creating the file.
  $ echo something > my.file

  # Enabling the noclobber option.
  $ set -o noclobber

  # Overwriting the file.
  $ echo some more >| my.file

  # Reading the file.
  $ cat my.file
  some more

  # Attempting to overwrite the file.
  $ echo once again > my.file
  bash: my.file: cannot overwrite existing file
  ```

### Standard Input

- Whether it is data for a program to crunch, or simple commands to direct the behaviour of a script, input is as
  fundamental as output.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Getting Input from File

- Use input redirection, indicated by the *<* character, to read data from a file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  wc < my.file
  ```

#### Keeping Your Data with Your Script

- In the case of needing input to your script, but don't want a separate file, use a here-document with the *<<*
  characters, redirecting the text from the command line than from a file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- In the following *ext* script, the *grep* has been parameterised by making the string that we're searching for be the
  parameter of our shell script (*\$1*). Whereas we often think of *grep* as searching for a fixed string through
  various different files, here we are going to vary what we search for, but search through the same data every time.
  Rather than supplying one or more filenames to search through, we set up a here-document and tell the shell to
  redirect standard input to come from that (temporary) document. The *<<* syntax says that we want to create such a
  temporary input source, and the *EOF* is just an arbitrary string (you can choose what you like) to act as the
  terminator of the temporary input. It is not part of the input, but acts as the marker to show where it ends. The
  regular shell script (if any) resumes after the marker.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat ext
  #
  # here is a "here" document
  #
  grep $1 <<EOF
  mike x.123
  joe x.234
  sue x.555
  pete x.818
  sara x.822
  bill x.919
  EOF
  $
  ```

#### Preventing Weird Behaviour in a Here-Document

- Your here-document is behaving weirdly. You wanted to maintain a simple list of
donors using the method described previously for phone numbers, so you created a
file called donors that looked like this:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat donors
  #
  # simple lookup of our generous donors
  #
  grep $1 <<EOF
  # name amt
  pete $100
  joe $200
  sam $ 25
  bill $ 9
  EOF
  $
  ```

- But when you tried running it you got weird output:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./donors bill
  pete bill00
  bill $ 9
  $ ./donors pete
  pete pete00
  $
  ```

- Turn off the shell scripting features inside the here-document by escaping any or all of the characters in the ending
  marker:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  grep $1 <<'EOF'
  pete $100
  joe $200
  sam $ 25
  bill $ 9
  EOF
  ```

- The *<<EOF* can be replaced with *<<\EOF*, or *<<'EOF'*, or even *<<E\OF* - they all work. It's not the most elegant
  syntax, but it's enough to tell *bash* that you want to treat the *here* data differently. Normally (i.e., unless you
  use this escaping syntax), says the *bash* manpage, "all lines of the here-document are subjected to parameter
  expansion, command substitution, and arithmetic expansion."
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- What's happening in our original donors script is that the amounts are being interpreted as shell variables. For
  example, *\$100* is being seen as the shell variable *\$1* followed by two zeros. That's what gives us pete00 when we
  search for *pete* and *bill00* when we search for *bill*. When we escape some or all of the characters of the EOF,
  *bash* knows not to do the expansions, and the behaviour is the expected behaviour:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./donors pete
  pete $100
  ```

- Of course, you may want the shell expansion on your data. It is a useful practice to always escape the marker, as in
  *<<'EOF'* or *<<\EOF*, to avoid unexpected results, unless you know that you really want the expansion to be done on
  your data.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Trailing whitespace (even just a single blank space) on your closing EOF marker will cause it not to be recognised as
  the closing marker. *bash* will swallow up the rest of your script, treating it as input too and looking for that
  *EOF*. Be sure there are no extra characters (especially spaces or tabs) after the *EOF*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Indenting Here-Documents

- Use *<<-*, and then you can use tab characters (only tab characters) at the beginning of lines to indent this portion
  of your shell script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat my_script.sh
  grep $1 <<-'EOF'
      lots of data
      can go here
      it's indented with tabs
      to match the script's indenting
      but the leading tabs are
      discarded when read
      EOF
  ls
  $
  ```

- The hyphen just after the *<<* is enough to tell bash to ignore the leading tab characters. This is for tab
  characters only and not arbitrary whitespace. Note that this is especially important with the *EOF* or any other
  marker designation. If you have spaces there, it will not recognise the *EOF* as your ending marker, and the *here*
  data will continue through to the end of the file (swallowing the rest of your script). Therefore, you may want to
  always left-justify the *EOF* (or other marker) just to be safe, and let the formatting go on this one line. If your
  script indents with spaces or a combination of spaces and tabs, don't use that technique on here-documents. Either
  use just tabs, or keep it all flush left. Also, watch out for text editors that automatically replace tabs with
  spaces.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Getting User Input

- Use the read statement to get input from the user.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  read

  read -p "answer me this " ANSWER

  read -t 3 -p "answer quickly: " ANSWER

  read PRE MID POST
  ```

- A *read* statement with no arguments will read user input and place it into the shell variable *REPLY*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If you supply multiple variable names in the read statement, then *read* parses the input into words, assigning them
  in order. If the user enters fewer words, the extra variables will be set to null. If the user enters more words than
  there are variables in the *read* statement, then all of the extra words will be part of the last variable in the
  list.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Getting a Yes or No Input

- You need to get a simple yes or no input from the user, and you want to be as user-friendly as possible. In
  particular, you do not want to be case-sensitive, and you want to provide a useful default if the user presses the
  *Enter* key.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If the actions to take are simple, use the following self-contained function:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # cookbook filename: func_choose
  # Let the user make a choice about something and execute code based on
  # the answer
  # Called like: choose <default (y or n)> <prompt> <yes action> <no action>
  # e.g. choose "y" \
  # "Do you want to play a game?" \
  # /usr/games/GlobalThermonuclearWar \
  # 'printf "%b" "See you later Professor Falkin.\n"' >&2
  # Returns: nothing
  function choose {
    local default="$1"
    local prompt="$2"
    local choice_yes="$3"
    local choice_no="$4"
    local answer

    read -p "$prompt" answer
    [ -z "$answer" ] && answer="$default"

    case "$answer" in
      [yY1] ) eval "$choice_yes"
      # error check
      ;;
      [nN0] ) eval "$choice_no"
      # error check
      ;;
      * ) printf "%b" "Unexpected answer '$answer'!" >&2 ;;
    esac
  } # end of function choose
  ```

- If the actions are complicated, use the function in the example below and handle the results in your main code.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # cookbook filename: func_choice.1
  # Let the user make a choice about something and return a standardised
  # answer. How the default is handled and what happens next is up to
  # the if/then after the choice in main.
  # Called like: choice <prompt>
  # e.g. choice "Do you want to play a game?"
  # Returns: global variable CHOICE
  function choice {
    CHOICE=''
    local prompt="$*"
    local answer

    read -p "$prompt" answer
      case "$answer" in
      [yY1] ) CHOICE='y';;
      [nN0] ) CHOICE='n';;
      * ) CHOICE="$answer";;
    esac
  } # end of function choice
  ```

- The code in the following example calls the *choice* function to prompt for and verify a package date. Assuming
  *\$THISPACKAGE* is set, the function displays the date and asks for verification. If the user types *y*, *Y*, or
  presses *Enter*, then that date is accepted. If the user enters a new date, the function loops and verifies it.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # cookbook filename: func_choice.2
  CHOICE=''
  until [ "$CHOICE" = "y" ]; do
    printf "%b" "This package's date is $THISPACKAGE\n" >&2

    choice "Is that correct? [Y/,<New date>]: "

    if [ -z "$CHOICE" ]; then
      CHOICE='y'
    elif [ "$CHOICE" != "y" ]; then
      printf "%b" "Overriding $THISPACKAGE with $CHOICE\n"
      THISPACKAGE=$CHOICE
    fi
  done
  ```

#### Selecting from a List of Options

- You need to provide the user with a list of options to choose from and you don't want to make them type any more than
  necessary. Use *bash*'s builtin *select* construct to generate a menu, then have the user choose by typing the number
  of the selection.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # cookbook filename: select_dir
  directorylist="Finished $(for i in /*;do [ -d "$i" ] && echo $i; done)"

  PS3='Directory to process? ' # Set a useful select prompt

  until [ "$directory" == "Finished" ]; do
    printf "%b" "\a\n\nSelect a directory to process:\n" >&2
    select directory in $directorylist; do
      # User types a number which is stored in $REPLY, but select
      # returns the value of the entry
      if [ "$directory" == "Finished" ]; then
        echo "Finished processing directories."
        break
      elif [ -n "$directory" ]; then
        echo "You chose number $REPLY, processing $directory..."
        # Do something here
        break
      else
        echo "Invalid selection!"
      fi # end of handle user's selection
    done # end of select a directory
  done # end of until dir == finished
  ```

- The select statement makes it trivial to present a numbered list to the user on *STDERR*, from which they may make a
  choice. Don't forget to provide an "exit" or "finished" choice, though Ctrl-D will end the *select* and empty input
  will print the menu again.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The number the user typed is returned in *\$REPLY*, and the value of that entry is returned in the variable you
  specified in the *select* construct.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Prompting for a Password

- Use the *read* command to read the user's input, but with a special option to turn off echoing.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The *-s* option tells the *read* command not to echo the characters typed (*s* is for silent) and the *-p* option
  says that the next argument is the prompt to be displayed prior to reading input. The line of input that is read from
  the user is put into the variable named *\$PASSWD*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- With echoing disabled, when the user presses the Enter key no newline is echoed and any subsequent output would
  appear on the same line as the prompt. Printing the newline gets us to the next line, as you would expect.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If you read a password into an environment variable it is in memory in plain text, and thus may be accessed via a
  core dump or */proc/core* (if your OS provides */proc/*). It is also in the process environment, which may be
  accessible by other processes. You may be better off using certificates with SSH, if possible. In any case, it is
  wise to assume that root and possibly other users on the machine may gain access to the password, so you should
  handle the situation accordingly.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

### Executing Commands

- The main purpose of *bash* (or of any shell) is to allow you to interact with the computer's operating system so that
  you can accomplish whatever you need to do. Usually that involves launching programs, so the shell takes the commands
  you type, determines from that input what programs need to be run, and launches them for you.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Running Any Executable

- Use *bash* and type the name of the command at the user input prompt when you need to run a command on a Linux or
  Unix system. This is simple on a surface level, but there are a lot of steps going on behind the scenes. The basic
  operation in *bash* is to load and execute programs. All the additional functionality provided by *bash* is to enable
  and facilitate the execution of programs.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- *bash* uses a shell variable called *\$PATH* to locate your executable. The *\$PATH* variable is a list of
  directories. The directories are separated by colons. *bash* searches in each of those directories for a file with
  the name that you specified. *bash* looks at the order in which the directories are listed in the variable, and takes
  the first executable found.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo $PATH
  /bin:/usr/bin:/usr/local/bin:.
  $
  ```

- The last directory in the list is just a single dot (called the dot directory, or just dot), which represents the
  current directory on a Linux or Unix filesystem - wherever you are, that's the directory to which dot refers.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Putting dot in the *\$PATH* is too great a security risk - someone could trick you and get you to run their own
  malicious version of a command (say, *ls*) in place of one that you were expecting. If dot were listed first, then
  someone else's version of *ls* would supersede the normal *ls* command, and you would likely unwittingly run that
  command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If you put dot as the last directory in your *\$PATH* variable, at least you won't be tricked that easily. Of course,
  if you leave it off altogether it is arguably even safer, and you can still run commands in your local directory by
  typing a leading dot and slash character.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  ./my_script
  ```

- Never allow dot or writeable directories in root's *\$PATH*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- A common practice among some *bash* users is to create a personal *bin* directory, analogous to the system
  directories */bin* and */usr/bin* where executables are kept. In your personal bin (if you create it in your *home*
  directory, its path is *~/bin*) you can put copies of your favourite shell scripts and other customised or private
  commands. Then add that directory to your *\$PATH*, even to the front (*PATH=~/bin:$PATH*). That way, you can still
  have your own customised favourites without the security risk of running commands from strangers.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Running Several Commands in Sequence

- There are two solutions to running several commands before manually inputting the next command after a successful
  execution of the previous command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - A shell script could be written to contain the commands order by the sequence of execution
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    ```bash
    $ cat > simple.script
    long
    medium
    short
    ^D # Ctrl-D, not visible
    $ bash ./simple.script
    ```

  - The arguably best solution is to run each command in sequence without a script.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    - If you want to run each program regardless of whether or not the preceding ones fail, separate them with
      semicolons.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    ```bash
    long ; medium ; short
    ```

    - If you only want to run the next program if the previous program was successful, and all the programs correctly
      set exit codes.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    ```bash
    long && medium && short
    ```

#### Running Several Commands All at Once

- You can run a command in the background by putting an ampersand at the end of the command line. Thus, you could
  fire off three commands in rapid succession.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ long &
  [1] 4592
  $ medium &
  [2] 4593
  $ short
  $
  ```

- You could streamline the execution of all three commands in one line.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ long & medium & short
  [1] 4592
  [2] 4593
  $
  ```

- When we run a command "in the background" (there really is no such place in Linux), all that really means is that we
  disconnect keyboard input from the command and the shell doesn't wait for the command to complete before it gives
  another prompt and accepts more command input. Output from the command (unless we take explicit action to change this
  behaviour) will still come to the screen, so in this example all three commands will be interspersing output to the
  screen.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If you run a command and then realise it will take longer to complete than you thought, you can pause it using
  *Ctrl-Z*, which will return you to a prompt. You can then type *bg* to unpause the job and continue running it in the
  background. This is essentially adding a trailing *&* after the fact.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Telling Whether a Command Succeeded or Not

- The shell variable *\$?* is set with a non-zero value if the command fails - provided the programmer who wrote that
  command or shell script followed the established convention.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ some_command
  # it works...
  $ echo $?
  0
  $ bad_command
  # it fails...
  $ echo $?
  1
  $
  ```

- The exit status of a command is kept in the shell variable referenced with *\$*?. Its value can range from 0 to 255.
  When you write a shell script, it's a good idea to have your script exit with zero if all is well and a non-zero
  value if you encounter an error condition. It it recommended to only use *0 to 127* because the shell uses *128+N* to
  denote *killed by signal N*. if you use a number greater than 255 or less than 0, the numbers will wrap around. You
  return an exit status with the exit statement (e.g., *exit 1* or *exit 0*).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Be aware that you only get one shot at reading a command's exit status. The second *echo* gives 0 as a result, as
  it's actually reporting on the status of the immediately preceding *echo* command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ bad_command
  # it fails...
  $ echo $?
  1
  $ echo $?
  0
  $
  ```

- As a result of the fact you only get one chance to check the exit status, many shell scripts will immediately assign
  the status to another shell variable.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ bad_command
  # it fails...
  $ STAT=$?
  $ echo $STAT
  1
  $ echo $STAT
  1
  $
  ```

- Although the examples shown in this section are in the command line, the real use of variables like *\$?* comes in
  writing scripts. You can usually see whether or not a command has been successful by watching it execute on your
  screen, but in a script the commands may be running unattended. The *exit* status is more often used in scripts, and
  often in *if* statements, to take different actions depending on the success or failure of a command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  some_command
  ...
  if (( $? )) ; then echo failed ; else echo OK; fi
  ```

- You should not use negative numbers for status codes. The shell with accept them without an error, but they will lead
  to unexpected behaviour.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ bash -c 'exit -2' ; echo $?
  254
  $ bash -c 'exit -200' ; echo $?
  56
  ```

#### Running a Command Only if Another Command Succeeded

- You need to run some commands, but you only want to run certain commands if certain other ones succeed. You can use
  the exit status (*\$?*) of the first command in combination with an *if* statement to do the subsequent command only
  if the first command was successful.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cd dir_name
  if (( $? == 0 )); then rm * ; fi
  ```

- If you're writing *bash* scripts, you'll want to be sure to explicitly set return values, so that *\$?* is set
  properly from your script. If you don't, the value set will be the value of the last command run, which you may not
  want as your result.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Using Fewer if Statements

- If you want to be thorough about your error checking, but don't want *if* statements all over the place in a script,
  you can have *bash* exit any time it encounters a failure (i.e., a nonzero exit status) from every command in your
  script (except in *while* loops and *if* statements where it is already capturing and using the exit status) by
  setting the *-e* flag.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  set -e
  cd temp_dir
  rm *
  ```

- Setting the *-e* flag in the previous example will cause the shell to exit when a command fails. If the *cd* in this
  example fails, the script will exit and never even try to execute the *rm \** command. You should not do this on an
  interactive shell, however, because when the shell exits it will make your shell window go away.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Running Long Jobs Unattended

- If you want to run a job in the background and expect to exit the shell before the job
  completes, then you need to *nohup* the job.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ nohup long &
  nohup: appending output to `nohup.out'
  $
  ```

- When you put a job in the background (via the &, as described in
  [Running Several Command All at Once](#running-several-commands-all-at-once)), it is still a child process of the
  *bash* shell. When you exit an instance of the shell, bash sends a hangup (*hup*) signal to all of its child
  processes.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The *nohup* command simply sets up the child process to ignore hangup signals. You can still kill the job with the
  *kill* command, because *kill* sends a *SIGTERM* signal, not a *SIGHUP* signal. But with *nohup*, *bash* won't
  inadvertently kill your job when you exit.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- *nohup* redirects the output for you, appending it (not overwriting, but adding at the end) to a file named
  *nohup.out* in the current directory. You can explicitly redirect the output elsewhere on the command line, and
  *nohup* is smart enough to detect that this has happened and not use *nohup.out* for your output.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Displaying Error Messages When Failures Occur

- A common idiom among some shell programmers is to use the *||* with commands to spit out debug or error messages,
  saving the necessity to write too many *if* statements.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cmd || printf "%b" "cmd failed. You're on your own\n"
  ```

- Similar to how the *&&* in [Using Fewer *if* Statements](#using-fewer-if-statements) tells *bash* not to bother to
  evaluate the second expression if the first one is false, the *||* tells the shell not to bother to evaluate the
  second expression if the first one is true (i.e., succeeds). Only if the first expression returns a non-zero value
  (i.e., if the exit value of the command indicates failure) must it evaluate the second part, and thus run the other
  command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The exit will be executed in either case in the following example.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cmd || printf "%b" "FAILED.\n" ; exit 1
  ```

- The *OR* is only between the first two commands in the previous example. If we want to have the *exit* happen only on
  error, we need to group it with the *printf* so that both are considered as a unit.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cmd || { printf "%b" "FAILED.\n" ; exit 1 ; }
  ```

#### Running Commands from a Variable

- You want to run different commands in your script depending on circumstances, you can assign the program name to a
  variable (*\$PROG* in the following example) , and then when the variable is referred to where a command name would be
  expected, *bash* uses the name of that variable as the command to run. It parses the command line, substitutes the
  values of its variables, and takes the result of all the substitutions and treats that as the command line, as if it
  had been typed that way verbatim.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  FN=/tmp/x.x
  PROG=echo
  $PROG $FN

  PROG=cat
  $PROG $FN
  ```

- There are many other possible solutions to this problem, other than the code in the previous example.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Be careful about the variable names you use, ensuring the variable names are not used by other programs.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Running All Scripts in a Directory

- If you want to run a series of scripts, but the list keeps changing; you're always adding new scripts, but you don't
  want to continuously modify a master list, put the scripts you want to run in a directory, and let *bash* run
  everything that it finds. Instead of keeping a master list, simply use the contents of that directory as your master
  list.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  for SCRIPT in /path/to/scripts/dir/*
  do
    if [ -f "$SCRIPT" -a -x "$SCRIPT" ]
    then
      $SCRIPT
    fi
  done
  ```

- There are no means to specify any arguments to the scripts as they are executed. This simple script may work well for
  your personal needs, but wouldn't be considered robust; some might consider it downright dangerous.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

### Basic Scripting: Shell Variables

- *bash* shell programming is a lot like any kind of programming, and that includes having variables - containers that
  hold strings and numbers, which can be changed, compared, and passed around. *bash* variables have some very special
  operators that can be used when you refer to a variable. *bash* also has some important built-in variables, ones that
  provide important information about the other variables in your script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- There are two significant aspects of *bash* variable syntax that may not be intuitively obvious. First, in the
  assignment, the *name=value* syntax is straightforward enough, but there cannot be any spaces around the equals sign.
  The flip side of this is also worth noting - don't use an equals sign in a filename, especially not one for a shell
  script (it is possible, just not recommended).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The second aspect of shell variable syntax worth noting is the use of the dollar sign when referring to a variable.
  You don't use the dollar sign on the variable name to assign it a value, but you do use the dollar sign to get the
  value of the variable. The exception to this is using variables inside a *\$(( ))* expression.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Since everything in *bash* is a string, we need the dollar sign to indicate a variable reference.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Embedding Documentation in Shell Scripts

- Embed documentation in the script using the "do nothing" builtin (a colon) and a here-document, when you want a
  simple way to provide formatted end-user documentation (e.g., manpages or HTML pages) for your script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: embedded_documentation

  echo 'Shell script code goes here'

  # Use a : NOOP and here document to embed documentation,
  : <<'END_OF_DOCS'

  Embedded documentation such as Perl's Plain Old Documentation (POD), or even plain text here.

  Any accurate documentation is better than none at all.

  Sample documentation in Perl's Plain Old Documentation (POD) format adapted from CODE/ch07/Ch07.001_Best_Ex7.1 and 7.2 in the Perl Best Practices example tarball "PBP_code.tar.gz".

  =head1 NAME

  MY~PROGRAM--One-line description here

  =head1 SYNOPSIS

    MY~PROGRAM [OPTIONS] <file>

  =head1 OPTIONS

    -h = This usage.
    -v = Be verbose.
    -V = Show version, copyright, and license information.

  =head1 DESCRIPTION

  A full description of the application and its features. May include numerous subsections (i.e., =head2, =head3, etc.)

  [...]

  =head1 LICENSE AND COPYRIGHT

  =cut

  END_OF_DOCS
  ```

- To extract and use the documentation from the previous example, enter the following commands.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # To read on-screen, automatically paginated
  $ perldoc my_script

  # Just the "usage" sections
  $ pod2usage my_script

  # Create an HTML version
  $ pod2html my_script > my_script.html

  # Create a manpage
  $ pod2man my_script > my_script.1
  ```

- Any plain-text documentation or markup can be used this way, either interspersed throughout the code, or better yet,
  collected at the end of the script. Since computer systems that have bash will probably also have Perl, its Plain Old
  Documentation (POD) format may be a good choice. Perl usually comes with *pod2\** programs to convert POD to HTML,
  LaTeX, manpage, text, and usage files.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Promoting Script Readability

- Follow these best practices when you would like to make your script as readable as possible for the ease of
  understanding and future maintenance.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Document your script as noted in [Embedding Documentation in Shell Scripts](
    #embedding-documentation-in-shell-scripts). Document your intent, not the trivial details of the code. If you
    follow the rest of the points, the code should be pretty clear. Write reminders, provide sample data layouts or
    headers, and make a note of all the details that are in your head now, as you write the code. Document the code
    itself too if it is subtle or obscure.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Indent and use vertical whitespace wisely. Ensure a consistent indentation level throughout the script. Add
    additional indentation for continued lines.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Use meaningful names for variables and functions, and spell them out. The only time *\$i* or *\$x* is ever
    acceptable is in a *for* loop. You may think that short, cryptic names are saving you time and typing now, but it
    is guaranteed that you will lose that time 10- or 100-fold somewhere down the line when you have to fix or modify
    your script.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Break lines at meaningful places at an agreed upon line length. Unfortunately, there are sometimes exceptions to
    the long line rule. When creating lines to pass elsewhere, perhaps via Secure Shell (SSH), and in certain other
    cases, breaking up the line can cause many more code headaches than it solves. But in most cases, it makes sense.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - Try to put the most meaningful bits to the left when you break a line - we tend to read shell code left-to-right,
    so the unusual fact of a continued line will stand out more. It's also easier to scan down the left edge of the
    code for continued lines, should you need to find them.
    [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  # Good
  [ -n "$results" ] \
    && echo "Got a good result in $results" \
    || echo 'Got an empty result, something is wrong'

  # Also good
  [ -n "$results" ] && echo "Got a good result in $results" \
                    || echo 'Got an empty result, something is wrong'

  # OK, but not ideal
  [ -n "$results" ] && echo "Got a good result in $results" \
    || echo 'Got an empty result, something is wrong'

  # Bad
  [ -n "$results" ] && echo "Got a good result in $results" || \
  echo 'Got an empty result, something is wrong'

  # Bad (trailing \s are optional here, but recommended for clarity)
  [ -n "$results" ] && \
  echo "Got a good result in $results" || \
  echo 'Got an empty result, something is wrong'
  ```

#### Separating Variable Names from Surrounding Text

- Use the full syntax for a variable reference, which includes not just the dollar sign, but also braces around the
  variable name when you need to print a variable along with other text and need to distinguish the end of the variable
  name from other text that follows.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- An example without the full syntax without a variable name.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  for FN in 1 2 3 4 5
  do
  some_script /tmp/rep$FNport.txt
  done
  ```

- An example without the full syntax without a variable name.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  for FN in 1 2 3 4 5
  do
  some_script /tmp/rep${FN}port.txt
  done
  ```

- Because shell variables can contain only alphanumeric characters and the underscore, there are many instances where
  you won't need to use the braces. Any whitespace or punctuation (except the underscore) provides enough of a clue to
  where the variable name ends. But when in doubt, use the braces. In fact, some people would argue that always using
  the braces is a good habit so you never have to worry about when they are needed or not, and provides a consistent
  look throughout your scripts. Others find that to be too much typing of characters that are optional but awkward to
  reach, and think they can make the code look very busy or noisy. Ultimately, it's a matter of personal preference.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Exporting Variables

- Export variables that you want to pass on to other scripts.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  export MY_VAR
  export NAME=value
  ```

- Sometimes it's a good thing that one script doesn't know about the other script's variables. You wouldn't want a
  script to impact the execution of another script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Sometimes you do want the information passed along. In those cases, you can export the variable so that its value is
  passed along to any other program that the script invokes.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- If you want to see a list of all the exported variables, just type the command *env* (or use the builtin *export -p*)
  for a list of each variable and its value.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- You can make the *export* part of any variable assignment, though that won't work in old versions of the shell. You
  can also have the *export* statement just name the variable that will be exported. Though the export statement can be
  put anywhere prior to where you need the value to be exported, script writers often group these statements together,
  like variable declarations, at the top of a script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Once exported, you can assign repeatedly to the variable without exporting it each time. The following is an example
  of this.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  export FNAME
  export SIZE
  export MAX
  ...
  MAX=2048
  SIZE=64
  FNAME=/tmp/scratch
  ```

- The following is another example.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  export FNAME=/tmp/scratch
  export SIZE=64
  export MAX=2048
  ...
  FNAME=/tmp/scratch2
  ...
  FNAME=/tmp/still_exported
  ```

- The exported variables are, in effect, call by value. Changing the value of the exported variable in the called
  script does not change that variable's value back in the calling script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Seeing All Variable Values

- Use the *set* command to see the values of all variables and function definitions in the current shell.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- Use the *env* (or *export -p*) command to see only those variables that have been exported and would be available to
  a subshell. The list produced by *env* is a subset of the list produced by set, since not all variables are exported.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- In *bash* version 4 or newer, you can also use the *declare -p* command.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The output from the newer *declare -p* command shows the variable names and values as if they were being declared and
  initialised. The output is in the form of *declare* statements that could be used as source code in a shell script to
  recreate these variables and their values. The various arguments (*-i*, *-x*, *-r*, *-a*) indicate that the variable
  is an integer, has been exported, is read-only, or is an array, respectively.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ declare -p
  ...
  declare -i MYCOUNT="5"
  declare -x MYENV="10.5.1.2"
  declare -r MYFIXED="unchangeable"
  declare -a MYRA=([0]="5" [1]="10" [2]="15")
  ...

  $
  ```

#### Using Parameters in a Shell Script

- Use command line parameters when you want users to be able to invoke your script with a parameter. It is a more
  straightforward solution than requiring users to set a shell variable, or pass data with another script.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- You don't need the braces for the single-digit numbers, except to separate the variable name from the surrounding
  text. Typical scripts have only a handful of parameters, but when you get to *\${10}* you need to use the braces
  because the shell will interpret *\$10* as *\${1}* followed immediately by the literal string *0*.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat tricky.sh
  echo $1 $10 ${10}

  $ ./tricky.sh I II III IV V VI VII VIII IX X XI
  I I0 X

  $
  ```

#### Looping Over Arguments Passed to a Script

- You may want to use the shell pattern matching to build a list of filenames that match the *\*.txt* pattern. This
  means that any number of arguments could be passed to the script to which you are passing the arguments.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  ./act_all *.txt
  ```

- To process any number of command line arguments that cannot be set strictly, use the shell special variable *\$\** to
  refer to all of your arguments, and use that in a *for* loop. The *for* loop will take the first value from the list,
  assign it to the variable *\$FN*, and proceed through the list of statements between the *do* and the *done.* It will
  then repeat that loop for each of the other values.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: chmod_all.1
  #
  # change permissions on a bunch of files
  #

  for FN in $*
  do
    echo changing $FN
    chmod 0750 $FN
  done
  ```

#### Handling Parameters with Spaces

- If we don't put quotes around the filename when we invoke the script, *bash* sees three arguments and substitutes the
  first argument (*Oh*) for *\$1*. The *ls* command runs with *Oh* as its only argument and can't find that file.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat simple.sh
  # simple shell script
  ls -l ${1}

  $

  $ ./simple.sh Oh the Waste
  ls: Oh: No such file or directory

  $
  ```

- Putting quotes around the file name when invoking the script does not resolve the issue, as the script means *ls*
  sees each word as a separate argument, meaning it can't find any of them.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./simple.sh "Oh the Waste"
  ls: Oh: No such file or directory
  ls: the: No such file or directory
  ls: Waste: No such file or directory

  $
  ```

- Putting quotes around the variable reference ensure *ls* treats the *"${1}"* is treated as a single argument.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ cat quoted.sh
  # note the quotes
  ls -l "${1}"

  $

  $ ./quoted.sh "Oh the Waste"
  -rw-r--r-- 1 smith users 28470 2007-01-11 19:22 Oh the Waste

  $
  ```

#### Handling Lists of Parameters with Spaces

- The *"$\*"* in the following script used in the *for* loop fails does not provided the expected behaviour when
  processing a file with a space in its name.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  for FN in "$*"
  do
    chmod 0750 "$FN"
  done
  ```

- The unexpected behaviour is caused by the *"$\*"* in the script, used in the *for* loop. For this case we need to use
  a different but related shell variable, *\$\@*. When it is quoted, the resulting list has quotes around each argument
  separately.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: chmod_all.2
  #
  # change permissions on a bunch of files
  # with better quoting in case of filenames with spaces
  #
  for FN in "$@"
  do
    chmod 0750 "$FN"
  done
  ```

- You should generally always use a *\$\@* in any *for* loops that iterate through an array. When you know your file
  names (or parameters in general) don't have spaces, it's okay to keep the traditional *\$\** syntax. For more robust
  scripting, the *\$\@* is the safer option. Both options will be used interchangeably throughout this book, as that
  was more familiar to the authors.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Counting Arguments

- Use the shell builtin variable *\$#* to determine how many parameters a script was invoked with.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: check_arg_count
  #
  # Check for the correct # of arguments:
  # Use this syntax or use: if [ $# -lt 3 ]

  if (( $# < 3 ))
  then
    printf "%b" "Error. Not enough arguments.\n" >&2
    printf "%b" "usage: my_script file1 op file2\n" >&2
    exit 1
  elif (( $# > 3 ))
  then
    printf "%b" "Error. Too many arguments.\n" >&2
    printf "%b" "usage: my_script file1 op file2\n" >&2
    exit 2
  else
    printf "%b" "Argument count correct. Proceeding...\n"
  fi
  ```

- The following is an example usage of the previous script, once with too many arguments and once with the correct
  number of arguments.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./my_script my_file is copied into your_file
  Error. Too many arguments.
  usage: my_script file1 op file2
  $ ./my_script my_file copy your_file
  Argument count correct. Proceeding...
  ```

- Don't confuse *\${#}* with *\${#VAR}* or even *\${VAR#alt}* just because they all use the hash character inside of
  curly braces. The first gives the number of arguments, whereas the second gives the length of the value in the
  variable *VAR* and the third does a certain kind of substitution.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Consuming Arguments

- Use *shift* to remove an argument after you've handled it.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: use_up_option
  #
  # use and consume an option
  #
  # parse the optional argument

  VERBOSE=0
  if [[ $1 = -v ]]
  then
    VERBOSE=1
    shift
  fi

  #
  # the real work is here
  #
  for FN in "$@"
  do
    if (( VERBOSE == 1 ))
    then
      echo changing $FN
    fi
      chmod 0750 "$FN"
  done
  ```

#### Getting Default Values

- Use the *\${:-}* syntax when referring to a parameter that you would like to have a default value, and use it to
  supply a default value. The *:-* operator says that if the specified parameter (here, *\$1*) is not set or is *null*,
  whatever follows (*/tmp* in our example) should be used as the value. Otherwise, it will use the value that is
  already set. It can be used on any shell variable, not just the positional parameters (*\$1*, *\$2*, *\$3*, etc.),
  but they are probably the most common use.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  FILE_DIR=${1:-/tmp}
  ```

#### Setting Default Values

- Your script relies on certain environment variables, either widely used ones (e.g., *$USER*) or ones specific to your
  own business. If you want to build a robust shell script, you should make sure that these variables each have a
  reasonable value. Use the assignment operator in the shell variable reference the first time you refer to it to
  assign a value to the variable if it doesn't already have one.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The reference to *$HOME* in the example will return the current value of *$HOME* unless it is empty or not set at
  all. In those cases (empty or not set), it will return the value */tmp*, which will also be assigned to *$HOME* so
  that further references to *$HOME* will have this new value.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo ${HOME:=/tmp}
  /home/uid002

  $ unset HOME # Generally not wise to do.

  $ echo ${HOME:=/tmp}
  /tmp

  $ echo $HOME
  /tmp

  $ cd && pwd
  /tmp
  $
  ```

- Once we unset the variable in the previous example, it no longer had any value. When we then used the *:=* operator
  as part of our reference to it, the new value (*/tmp*) was substituted. The subsequent references to *$HOME* returned
  its new value. One important exception to keep in mind about the assignment operator: this mechanism will not work
  with positional parameter arguments (e.g., *\$1 or *\$\**). For those cases, use *:-* in expressions like
  *\${1:-default*}, which will return the value without trying to do the assignment.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- It might help you to remember some of these crazy symbols if you think of the visual difference between
  *\${VAR:=value}* and *\${VAR:-value}*. The *:=* will do an assignment as well as returning the value to the right of
  the operator. The *:-* will do half of that - it returns the value but doesn't do the assignment - so its symbol is
  only half of an equals sign (i.e., one horizontal bar, not two).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Using *null* as Valid Default Value

- The *\${:=}* operator has two cases where the new value will be used: first, when the value of the shell variable has
  previously not been set (or has been explicitly unset); and second, where the value has been set but is empty, as in
  *HOME=""* or *HOME=\$OTHER* (where *\$OTHER* has no value).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- The shell can distinguish between the two cases in the previous point, and omitting the colon (*:*) indicates that
  you want to make the substitution only if the value is unset. If you write only *\${HOME=/tmp}* without the colon,
  the assignment will take place only in the case where the variable is not set (never set or explicitly unset).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

- In the case where we simply made the *\$HOME* variable an empty string, the *=* operator didn't do the substitution
  since *\$HOME* did have a value, albeit *null*. But when we unset the variable, the substitution occurred. If you
  want to allow for empty strings, use just the *=* with no colon. Most times, though, the *:=* is used because you can
  do little with an empty value, deliberate or not.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ echo ${HOME=/tmp} # no substitution needed
  /home/uid002

  $ HOME=""
  # generally not wise

  $ echo ${HOME=/tmp} # will NOT substitute
  $ unset HOME
  # generally not wise

  $ echo ${HOME=/tmp}
  # will substitute
  /tmp

  $ echo $HOME
  /tmp

  $
  ```

#### Using More than Just a Constant String for Default

- You can use quite a bit more on the right-hand side of these shell variable references. The value that will be
  substituted doesn't have to be just a *string* constant. Rather, it can be the result of a more complex shell
  expression, including running commands in a subshell (as in the following example).
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  cd ${BASE:="$(pwd)"}
  ```

- The *bash* manpage says that what we put to the right of the operator "is subject to tilde expansion, parameter
  expansion, command substitution, and arithmetic expansion."
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - **Parameter expansion**:

    - Means that other shell variables can be used in the expression, as in *\${BASE:=\${HOME}}*
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - **Tilde Expansion**:

    - Using an expression like *~bob* will refer to the home directory of the user *bob*.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    - Use *\${BASE:=~uid17}* to set the default value to the home directory for the user *uid17*. Don't put quotes
      around the string, as that will defeat the tilde expansion.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - **Command Substitution**:

    - Commands are enclosed in the single parentheses syntax, *\$(cmds)*.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  - **Arithmetic Expansion**:

    - Means that we can do integer arithmetic, using *\$(())* syntax in this expression.
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

    - For example: *echo \${BASE:=/home/uid\$((ID+1))}*
      [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

#### Giving an Error Message for Unset Parameters

- sometimes you need to force the users to give you a value; otherwise, you don't want to proceed. Instead of several
  *if* statements to check each of the several parameters, use the *\${:?}* syntax when referring to the parameters.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  #!/usr/bin/env bash
  # cookbook filename: check_unset_parms
  #
  USAGE="usage: myscript scratchdir sourcefile conversion"
  FILEDIR=${1:?"Error. You must supply a scratch directory."}
  FILESRC=${2:?"Error. You must supply a source file."}
  CVTTYPE=${3:?"Error. ${USAGE}"}
  ```

- If you run the script with insufficient arguments:
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./myscript /tmp /dev/null
  ./myscript: line 7: 3: Error. usage: myscript scratchdir sourcefile conversion

  $
  ```

- The error message produced by the ${:?} feature includes shell script filename and line number.
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition)

  ```bash
  $ ./check_unset_parms
  ./check_unset_parms: line 5: 1: Error. You must supply a scratch directory.

  $ ./check_unset_parms somedir
  /tmp/check_unset_parms: line 6: 2: Error. You must supply a source file.

  $ ./check_unset_parms somedir somefile
  ./check_unset_parms: line 7: 3: Error. usage: myscript scratchdir sourcefile \
  conversion
  ```

#### Changing Pieces of a String

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting the Absolute Value of a Number

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *bash* for *basename*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *bash* for *dirname*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Alternate Values for Comma-Separated Values

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Array Variables

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting Between Upper- and Lowercase

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting to Camel Case

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Shell Logic & Arithmetic

#### Doing Arithmetic in Your Shell Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Branching on Conditions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing for File Characteristics

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing for More than One Thing

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing for String Characteristics

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing for Equality

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing with Pattern Matches

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing with Regular Expressions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Changing Behaviour with Redirections

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Looping for a While

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Looping with a *read*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Looping with a Count

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Looping with Floating-Point Values

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Branching Many Ways

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Command-Line Arguments

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating Simple Menus

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Changing the Prompt on Simple Menus

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating a Simple RPN Calculator

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating a Command-Line Calculator

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Intermediate Shell Tools I

#### Sifting Through Files for a String

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting Just the Filename from a Search

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting a Simple True/False from a Search

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Searching for Text While Ignoring Case

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Doing a Search in a Pipeline

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Paring Down What the Search Finds

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Searching with More Complex Patterns

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Searching for an SSN

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Grepping Compressed Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Keeping Some Output, Discarding the Rest

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Keeping Only a Portion of a Line of Output

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Reversing the Words on Each Line

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Summing a List of Numbers

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Counting String Values with *awk*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Counting String Values with *bash*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Showing Data as a Quick and Easy Histogram

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### An Easy Histogram with *bash*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Showing a Paragraph of Text After a Found Phrase

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Intermediate Shell Tools II

#### Sorting Your Output

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Sorting Numbers

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Sorting IP Addresses

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Cutting Out Parts of Your Output

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Removing Duplicate Lines

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Compressing Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Uncompressing Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Checking a *tar* Archive for Unique Directories

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Translating Characters

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting Uppercase to Lowercase

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting DOS Files to Linux Format

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Removing Smart Quotes

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Counting Lines, Words, or Characters in a File

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Rewrapping Paragraphs

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Doing More with *less*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Finding Files: *find*, *locate*, *slocate*

#### Finding All Your MP3 Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Handling Filenames Containing Odd Characters

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Speeding Up Operations on Found Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Files Across Symbolic Links

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Files Irrespective of Case

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Files by Date

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Files by Type

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding File by Size

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Files by Content

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Existing Files & Content Fast

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding a File Using a List of Possible Locations

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Additional Features for Scripting

#### "Daemon-ising" Your Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Reusing Code with Includes & Sourcing

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Configuration Files in a Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Defining Functions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Functions: Parameters & Return Values

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Trapping Interrupts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Redefining Commands with *alias*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Avoiding Aliases & Functions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Counted Elapsed Time

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Writing Wrappers

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Working with Dates & Times

#### Formatting Dates for Display

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Supplying a Default Date

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Automating Date Ranges

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting Dates & Times to Epoch Seconds

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting Epoch Seconds to Dates & Times

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting Yesterday or Tomorrow with Perl

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Figuring Out Date & Time Arithmetic

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Handling Time Zones, Daylight Saving Time, & Leap Years

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *date* & *cron* to Run a Script on the Nth Day

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Logging with Dates

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### End-User Tasks as Shell Scripts

#### Starting Simple by Printing Dashes

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Viewing Photos in an Album

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Loading Your MP3 Player

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Burning a CD

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Comparing Two Documents

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Parsing & Similar Tasks

#### Parsing Arguments for Your Shell Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Arguments with Your Own Error Messages

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Some HTML

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Output into an Array

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Output with a Function Call

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing Text with a *read* Statement

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing with *read* into an Array

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Reading an Entire File

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting Your Plurals Right

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Taking It One Character at a Time

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Cleaning Up an SVN Source Tree

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting Up a Database with MySQL

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Isolating Specific Fields in Data

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Updating Specific Fields in Datafiles

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Trimming Whitespace

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Compressing Whitespace

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Processing Fixed-Length Records

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Processing Files with No Line Breaks

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Converting a Datafile to CSV

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Parsing a CSV Datafile

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Writing Secure Shell Scripts

#### Avoiding Common Security Problems

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Avoiding Interpreter Spoofing

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting a Secure *\$PATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Clearing All Aliases

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Clearing the Command Hash

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Preventing Core Dumps

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting a Secure *\$IFS*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting a Secure *umask*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding World-Writeable Directories in Your *\$PATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Adding the Current Directory to the *\$PATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Secure Temporary Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Validating Input

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting Permissions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Leaking Passwords into the Process List

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Writing *setuid* or *setgid* Scripts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Restricting Guest Users

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *chroot* Jails

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Running as Non-root User

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *sudo* More Securely

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Passwords in Scripts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using SSH Without a Password

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Restricting SSH Commands

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Disconnecting Inactive Sessions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Advanced Scripting

#### Finding *bash* Portable for *#!*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting a POSIX *\$PATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Developing Portable Shell Scripts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing Scripts Using Virtual machines

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *for* Loops Portably

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *echo* Portably

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Splitting Output Only When Necessary

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Viewing Output in Hex

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *bash* Net-Redirection

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding My IP Address

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting Input from Another Machine

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Redirecting Output for the Life of a Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Working Around *"Argument list too long"* Errors

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Logging to *syslog* from Your Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *logger* Correctly

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Sending Email from Your Script

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Automating a Process Using Phases

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Doing Two Things at Once

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Running an SSH Command on Multiple Hosts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Configuring & Customising *bash*

#### *bash* Startup Options

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Customising Your Prompt

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### A Prompt Before Your Program Runs

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Changing Your *\$PATH* Permanently

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Changing Your *\$PATH* Temporarily

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting Your *\$CDPATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### When Programs Are Not Found

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Shorting or Changing Command Names

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Adjusting Shell Behaviour & Environment

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Adjusting *readline* Behaviour Using *.inputrc*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Keeping a Private Stash of Utility by Adding *~/bin*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Secondary Prompts: *\$PS2*, *\$PS3*, *\$PS4*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Synchronising Shell History Between Sessions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Setting Shell History Options

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating a Better *cd* Command

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating & Changing Into a New Directory in One Step

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting to the Bottom of Things

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Adding New Features to *bash* Using Loadable Builtins

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Improving Programmable Completion

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using Initialisation Files Correctly

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating Self-Contained, Portable *rc* Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Getting Start with a Custom Configuration

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Housekeeping & Administrative Tasks

#### Renaming Many Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using GNU Texinfo & *info* on Linux

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Unzipping Many ZIP Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Recovering Disconnected Sessions Using *screen*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Sharing a Single *bash* Session

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Logging an Entire Session or Batch Job

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Clearing the Screen When You Log Out

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Capturing File Metadata for Recovery

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Creating an Index of Many Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *diff* & *patch*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Counting Differences in Files

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Removing or Renaming Files Named with Special Characters

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Prepending Data to a File

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Editing a File in Place

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Using *sudo* on a Group of Commands

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Lines That Appear in One File but Not in Another

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Keeping the Most Recent N Objects

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Writing to a Circular Log

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Circular Backups

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Grepping *ps* Output Without Also Getting the *grep* Process Itself

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finding Out Whether a Process Is Running

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Adding a Prefix or Suffix to Output

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Numbering Lines

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Writing Sequences

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Emulating the DOS Pause Command

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Commodifying Numbers

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Working Faster by Typing Less

#### Moving Quickly Among Arbitrary Directories

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Repeating the Last Command

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Quick Substitution

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Reusing Arguments

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Finishing Names for You

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Playing It Safe

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Big Changes, More Lines

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

### Tips & Traps: Common Goofs for Notices

#### Forgetting to Set Execute Permissions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Fixing *"No such file or directory"* Errors

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Forgetting That the Current Directory Is Not in the *\$PATH*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Naming Your Script *"test"*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Expecting to Change Exported Variables

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Forgetting Quotes Leads to *"command not found"* on Assignments

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Forgetting that Pattern Matching Alphabetises

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Forgetting that Pipelines Make Subshells

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Making Your Terminal Sane Again

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Deleting Files Using an Empty Variable

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Seeing Odd Behaviour from *printf*

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Testing *bash* Script Syntax

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Debugging Scripts

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Avoid *"command not found"* When Using Functions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

#### Confusing Shell Wildcards & Regular Expressions

<!-- - 
  [O'Reilly: *bash* Cookbook, 2nd Edition](#oreilly-bash-cookbook-2nd-edition) -->

</details>

## The Pragmatic Programmer

<details open>

<summary>Click to expand/minimise the full contents of this book.</summary>

### Preface to the Second Edition

#### How the Book is Organised

- The book is written as a collection of short topics. Each topic is self-contained and addresses a particular theme.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There is a list of tips throughout the book, often emphasising points in the accompanying text. The following is the
  list of tips:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - [Tip 1: Care About Your Craft](#tip-1-care-about-your-craft)

  - [Tip 2: Think! About Your Work](#tip-2-think-about-your-work)

  - [Tip 3: You Have Agency](#tip-3-you-have-agency)

  - [Tip 4: Provide Options, Don't Make Lame Excuses](#tip-4-provide-options-dont-make-lame-excuses)

  - [Tip 5: Don't Live with Broken Windows](#tip-5-dont-live-with-broken-windows)

  - [Tip 6 Be a Catalyst for Change](#tip-6-be-a-catalyst-for-change)

  - [Tip 7: Remember the Big Picture](#tip-7-remember-the-big-picture)

  - [Tip 8: Make Quality a Requirements Issue](#tip-8-make-quality-a-requirements-issue)

  - [Tip 9: Invest Regularly in Your Knowledge Portfolio](#tip-9-invest-regularly-in-your-knowledge-portfolio)

  - [Tip 10: Critically Analyse What You Read \& Hear](#tip-10-critically-analyse-what-you-read--hear)

  - [Tip 11: English is Just Another Language](#tip-11-english-is-just-another-language)

  - [Tip 12: It's Both What You Say and the Way You Say It](#tip-12-its-both-what-you-say-and-the-way-you-say-it)

  - [Tip 13: Build Documentation In, Don't Bolt It On](#tip-13-build-documentation-in-dont-bolt-it-on)

  - [Tip 14: Good Design is Easier to Change Than Bad Design](#tip-14-good-design-is-easier-to-change-than-bad-design)

  - [Tip 15: DRY - Don't Repeat Yourself](#tip-15-dry---dont-repeat-yourself)

  - [Tip 16: Make It Easy to Rescue](#tip-16-make-it-easy-to-rescue)

  - [Tip 17: Eliminate Effects Between Things](#tip-17-eliminate-effects-between-things)

  - [Tip 18: There Are No Final Decisions](#tip-18-there-are-no-final-decisions)

  - [Tip 19: Forego Following Fads](#tip-19-forego-following-fads)

  <!-- - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx)

  - [Tip xx:](#tip-xx) -->

- Exercises and challenges have been added where appropriate. Exercises normally have straightforward answers, while
  the challenges are more open-ended.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### What's In a Name?

- The first time jargon is used in the book, it is usually defined, or at least a hint is given to its meaning.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Perfectly good jargon is ignored numerous times throughout the book, as the jargon is normally restricted to a
  particular problem domain, or to a particular phase of development.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

### From the Preface to the First Edition

- Programming is a craft. At its simplest, it comes down to getting a computer to do what you want it to do (or what
  the user wants it to do). As a programmer, you are part listener, part adviser, part interpreter, and part dictator
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- You try to capture elusive requirements and find a way of expressing them so that a mere machine can do them justice.
  You try to document your work so that others can understand it, and you try to engineer your work so that others can
  build on it.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There are no easy answers. There is no best solution, be it a tool, a language, or an operating system. There can
  only be systems that are more appropriate in a particular set of circumstances.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- You shouldn't be wedded to any particular technology, but have a broad enough background and experience base to allow
  you to choose good solutions in particular situations.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- You adjust your approach to suit the current circumstances and environment. You judge the relative importance of all
  the factors affecting a project and use your experience to produce appropriate solutions. You do this continuously as
  the work progresses.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Who Should Read This Book?

- The book is aimed at people who want to become more effective and more productive programmers. Perhaps you feel
  frustrated you don't seem to be achieving your potential. Perhaps you look at colleagues who seem to be using tools
  to make themselves more producing than you. Maybe your current job uses older technologies, and you want to know how
  newer ideas can be applied to what you do.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### What Makes a Pragmatic Programmer?

- Each developer is unique, with individual strengths and weaknesses, preferences and dislikes. Over time, each will
  craft their own personal environment, reflecting the developer's individuality.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- If you're a Pragmatic Programmer, you'll share many of the following characteristics:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Early Adopter/Fast Adapter**:

    - You have an instinct for technologies and techniques, and you love trying things out. When given something new,
      you can grasp it quickly and integrate it with the rest of your knowledge.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Inquisitive**:

    - You tend to ask questions, eager to learn facts, each of which may affect some decision years from now.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Critical Thinker**:

    - You rarely take things as given without first getting the facts.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Realistic**:

    - You try to understand the underlying nature of each problem you face. Deeply understanding that a process
      shouldn't be difficult or will take a while to complete gives you the stamina and confidence to keep at it and
      suggest improvements where appropriate.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Jack of All Trades**:

    - You try hard to be familiar with a broad range of technologies and environments, and you work to keep abreast of
      new developments. Although your current job may require you to be a specialist, you will always be able to move
      on to new areas and new challenges.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 1: Care About Your Craft

- There is no point in developing software unless you care about doing it well.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 2: Think! About Your Work

- Think about what you're doing while you're doing it. An ongoing critical appraisal of every decision you make, every
  day, and on every project is required to truly make a difference to you and your organisation. Never run on
  auto-pilot. Constantly be thing, critiquing your work in real time.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Individual Pragmatists, Large Teams

- Within the overall structure of a project, there is always room for individuality and craftsmanship. This is
  particularly true given the state of software engineering.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### It's a Continuous Process

- Every day, work to refine the skills you have and to add new tools to your repertoire.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

### A Pragmatic Philosophy

#### It's Your Life

- Software development must appear close to the top of any list of carers where you have control. Our skills are in
  demand, our knowledge crosses geographic boundaries, we can work remotely. We're paid well. We really can do just
  about anything we want.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- For some reasons, developers seem to resist change. They hunker down and hope things will get better. They look on,
  passively, as their skills become dated and complain their companies don't train them.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 3: You Have Agency

- If technology seems to be passing you by, make time (in your own time) to study new material that looks interesting.
  You're investing in yourself, so doing it while you're off the clock is only reasonable.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The industry give you a remarkable set of opportunities. Be proactive, and take them.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### The Cat Ate My Source Code

- Pragmatic Programmers take charge of their own career, and aren't afraid to admit ignorance or error. These things
  happen, and we try to deal with them as professionally as we can. This means being honest and direct. We can be proud
  of our abilities, but we must own up to our own shortcomings - our ignorance and our mistakes.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Team Trust

- Above all, your team needs to be able to trust and rely on you - and you need to be comfortable relying on each of
  them as well.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- In a healthy environment based on trust, you can safely speak your mind, present your ideas, and rely on your team
  members who can in turn rely on you.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Take Responsibility

- Responsibility is something you actively agree to. You make a commitment to ensure everything is done right, but you
  don't necessarily have direct control over every aspect of it.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- You have the right to not take on a responsibility or an impossible situation, or one in which the risks are too
  great, or the ethical implications too sketchy.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When you do accept the responsibility for an outcome, you should expect to be held accountable for it. When you make
  a mistake (as we all do) or an error in judgement, admit it honestly, and try to offer options.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Don't blame someone or something else, or make up an excuse. Don't blame all the problems on a vendor, a programming
  language, management, or your coworkers. All of them may play a role, but it is up to you to provide solutions, and
  try to offer options.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 4: Provide Options, Don't Make Lame Excuses

- Before you approach anyone to tell them why something can't be done, is late, or is broken, stop and listen to
  yourself. Instead of excuses, provide options. Don't say it can't be done: explain what can be done to salvage the
  situation.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Perhaps you need additional resources to complete this task. Don't be afraid to ask for anything to help complete
  your work, or to admit that you need help.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Take Responsibility)

- How do you react when someone comes to you with a lame excuse? What do you think of them and their organisation as a
  result?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When you find yourself saving "I don't know", be sure to follow up with with "but I'll find out". It's a great way to
  admit what you don't know, but then take responsibility for finding information like a professional.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Software Entropy

- Entropy is a term from physics that refers to the amount of "disorder" in a system.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When disorder increases in software, we call it "software rot", or more optimistically, "technical debt".
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There are many factors that can contribute to software rot. The most important seems to be the psychology, or
  culture, at work on a project.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 5: Don't Live with Broken Windows

- Don't leave "broken windows" - bad designs, wrong decisions, or poor code - unrepaired. Fix each one as soon as it is
  discovered. If there is an insufficient time to fix it properly, then provide a temporary fix. Take some action to
  prevent further damage and to show that you're on top of a situation.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There are other factors that can contribute to software rot, but neglect accelerates the rot faster than any other
  factor.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Don't let entropy win.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### First, Do No Harm

- One "broken window" - a badly designed piece of code, a poor management decision that the team must live with for the
  duration of the project - is all it takes to start the decline.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- If you start working on a project with quite a few "broken windows". It's all too easy to slip into the mindset of
  "All the rest of this code is crap, I'll just follow suit."
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- In the same token, if you find yourself on a project where the code is immaculate - pristine, cleanly written,
  well-designed, and elegant - you will likely take extract special care not to mess it up. Even if there's pressure on
  make a change, you don't want to be the first one to make a mess and inflict any additional damage to the project.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Software Entropy)

- Help strengthen your team be surveying your project "neighbourhood". Choose two or three "broken windows" and discuss
  the problems - and their possible solution - with your colleagues.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Can you tell when a "window" first gets "broken"? What is your reaction? If it was the result of someone else's
  decision, or a management edict, what can you do about it?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Stone Soup & Boiled Frogs

- You may be in a situation where you know exactly what needs doing and how to do it. Ask permission to tackle the
  whole thing and you'll be met with delays and blank stares. People will form committees, budgets will need approval,
  and things will get complicated. Everyone will guard their resources. Sometimes this is called "start-up fatigue."
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Work out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them marvel. Then
  say it would be better to add minor things, pretending they aren't important. Keep in mind, it's easier to ask
  forgiveness than it is to get permission.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 6 Be a Catalyst for Change

- You can't force change on people. Instead, show them how the future might be and help them participate in creating it.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### The Villager's Side

- Projects slowly and inexorably get totally out of hand. Most software disasters start out too small to notice, and
  most project overruns happen a day at a time. It's often the accumulation of small things that breaks morale and
  teams.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 7: Remember the Big Picture

- Don't get so engrossed on the details that you forget to check what's happening around you. Keep an eye on the big
  picture. Constantly review what's happening around you, not just what you personally are doing.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (The Villager's Side)

- By progressively deceiving your organisation (as outlined in the
  [Stone Soup & Boiled Frogs](#stone-soup--boiled-frogs) section), you're doing it harm. Can you determining whether
  you're making the necessary changes for the right reasons or causing unnecessary scope creep? Is the decision
  subjective or objective?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Get in the habit at looking for anything that seems out of place for your project, such as existing code, practices,
  or requirements.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Good Enough Software

- The phrase "good enough" does not imply sloppy or poorly produced code. All systems must meet their users'
  requirements to be successful, and meet basic performance, privacy, and security standards. Users should be given the
  opportunity to participate in the process of deciding when what you've produced is good enough for their needs.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Involve Your Users in the Trade Off

- Normally software is written for other people. What is required is often asked, but how good it is wanted is rarely
  considered. Sometime there will be no choice.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The scope and quality of the system you produce should be discussed as part of that system's requirements.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 8: Make Quality a Requirements Issue

- Many customers would rather use software with some rough edges today than wait a year for a pristine version,
  especially considering their requirements are likely to change during that year. If you give your users something to
  play with early, their feedback will often lead you to a better eventual solution.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Know When to Stop

- Don't spoil a perfectly good program by over-embellishment and over-refinement. Move on, and let your code stand in
  its own right for a while. It may not be perfect, but don't worry, it could never be perfect.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Good Enough Software)

- Look at the software tools and operating systems that you use regularly. Can you find any evidence that these
  organisations and/or developers are comfortable shipping software they know is not perfect?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Consider the effect of modularisation on the delivery of software. Will it take more or less time to deliver a
  tightly-coupled monolithic block of software to the required quality compared with a system designed as very
  loosely-coupled modules or microservices?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Can you think of popular software that suffers from feature bloat (more features than you would ever use), each
  feature introducing more opportunity for bugs and security vulnerabilities, and making it harder to use and manage
  the features you do use? Are you in danger of falling into this trap yourself?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Your Knowledge Portfolio

- Your knowledge and experience are your most important day-to-day professional assets. Unfortunately, they're expiring
  assets. Your knowledge becomes out of date as new techniques, and environments are developed. As the value of your
  knowledge declines, so does your value to your company or client. We want to prevent this from ever happening.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- A programmer's knowledge portfolio can be considered as all the facts they know about computing, the application
  domains they work in, and their experience. Managing a knowledge portfolio is very similar to managing a financial
  portfolio:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Serious investors invest regularly, as a habit.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Diversification is the key to long-term success.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Smart investors balance their portfolios between conservative and high-risk, high-reward investments.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Investors try to buy low and sell high for maximum return.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Portfolios should be reviewed and rebalanced periodically.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Managing this kind of investment is a skill just like any other - it can be learned. The trick is to do it initially
  and to format a habit. Develop a routine which you follow until your brain internalises it.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Building Your Portfolio

- **Invest Regularly**:

  - You must invest in your knowledge portfolio regularly, even if it's just a small amount. Plan to use a consistent
    time and place, away from interruptions.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Diversify**:

  - The more different things you know, the more valuable you are. The more technologies you are comfortable with, the
    better you will be able to adjust to change.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Manage Risk**:

  - Technology exists on a spectrum from risky, potentially high-reward to low-risk, low-reward standards. It's not a
    good idea to invest all your money or skills in one basket.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Buy Low, Sell High**:

  - Learning an emerging technology before it becomes popular can be just as hard as finding an undervalued stock, but
    the payoff can be just as rewarding.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Review & Rebalance**:

  - This is a very dynamic industry. You might spend time learning a technology that ends up dying, or have to re-learn
    a technology you learned and possibly used in the past.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 9: Invest Regularly in Your Knowledge Portfolio

- Aspire to the following goals:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Learn at Least One New Language Every Year**:

    - Different languages solve the same problems in different ways. By learning several different approaches, you can
      help broaden your thinking.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Read a Technical Book Each Month**:

    - Browse the booksellers for technical books on interesting topics related to your current project. After you've
      mastered the technologies you're currently using, branch out and study some that don't relate to your project.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Read Non-Technical Books, Too**:

    - Don't forget the human side of software development, as that requires an entirely different skill set than
      technical skills.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Take Classes**:

    - Look for interesting courses at a hotel or online college or university, or perhaps at the next nearby trade show
      or conference.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Participate in Local User Groups and Meetups**:

    - Isolation can be deadly to your career: find out what people are working on outside of your company.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Experiment with Different Environments**:

    - Spend some time with Linux if you've only worked on Windows. Use an IDE if you've only used command line tools,
      or vice versa.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Stay Current**:

    - Read news and posts online on technology different from that of your current project.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Once you feel comfortable with some new language or bit of technology, move on. Learn another one. The
  cross-pollination of ideas is important: try to apply the lessons you've learned to your current project. Even if
  your project doesn't use that technology, perhaps you can borrow some ideas.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Opportunities for Learning

- If someone asks you a question that you can't answer, take it as a personal challenge to find the answer.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Reading and researching takes time, and time is already in short support. You need to plan ahead. Always have
  something to read in an otherwise quiet/idle moment.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Critical Thinking

- You need to ensure the knowledge in your portfolio is accurate and unswayed by either vendor or media hype. Beware of
  the zealots who insist their dogma provides the only answer - it may or may not applicable to you and your project.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Never underestimate the power of commercialism. Just because a web search engine lists a hit first doesn't mean that
  it's the best match.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 10: Critically Analyse What You Read & Hear

- Critical thinking is an entire discipline unto itself. Read and study all you can about it. The following are a few
  questions to ask and think about every time you work on something in future:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Ask the "Five Whys"**:

    - Ask "Why?" at least five times. Ask a question and get an answer. Dig deeper by asking "Why?" You might be able
      to get closer to a root cause this way.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Who Does This Benefit?**:

    - Follow the money can be a very helpful path to analyse. The benefits to someone else or another organisation may
      be aligned with your own, or not.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **What's the Context?**:

    - Everything occurs in its own context, which is why "one size fits all" solutions often don't. Consider an article
      or book touting "best practices." Good questions to ask are "best for who?" What are the prerequisites, what are
      the consequences, short and long term?
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **When or Where Would This Work?**:

    - Under what circumstances? Is it too late? Is it too early? Don't stop with thinking what will happen next, think
      about what will happen after that.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Why is This a Problem?**:

    - Is there an underlying model? How does the underlying model?
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Unfortunately, there are very few simple answers, but your knowledge portfolio should help you understand the
  increasingly complex answers.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Your Knowledge Portfolio)

- Start learning a new language this week.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Start reading a new book. If you are doing very detailed implementation and coding, read a book on design and
  architecture.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Get out and talk technology with people who aren't involved in your current project, or who don't work for the same
  company.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Communicate

- A good idea is an orphan without effective communication.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- As developers, we have to communicate on many levels. A large part of our day is spend communicating, so we need to
  do it well.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 11: English is Just Another Language

- Treat your native tongue as just another programming language. Write natural language as you would code: honour the
  DRY (Don't Repeat Yourself) principle, the ETC (Easier to Change) principle, automation, etc.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Know Your Audience

- You're communicating only if you're conveying what you mean to convey - just talking isn't enough. To do that, you
  need to understand the needs, interests, and capabilities of your audience.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- By making the appropriate pitch to the relevant group, you'll get them all excited about your project.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- As with all forms of communication, the key is to gather feedback. Don't just wait for questions: ask for them.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Know What You Want to Say

- Plan what you want to say. Write an outline. Then ask yourself. "Does this communicate what I want to express to my
  audience in a way that works for them?" If not, refine it until it does.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When you're faced with an important meeting or a chat with a major client, jot down the ideas you want to
  communicate, and plan a few strategies for getting them across.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Choose Your Moment

- As part of understanding what your audience needs to hear, you need to work out what their priorities are. Make sure
  what you're saying is relevant in time, as well as in content. Sometime, all it takes is a simple question "Is this a
  good time to talk about...?"
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Choose a Style

- Adjust the style of your delivery to suit your audience. Determine the style of your delivery based on what they are
  likely to expect or appreciate, or what they've explicitly said they want.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- If you are unable to communicate in the way your audience expects, be sure to provide that feedback. Feedback is also
  a form of communication.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Make it Look Good

- Your ideas are important. They ought to look good to convey them to your audience.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Too many developers (and their managers) concentrate solely on content when producing written documents. This is a
  mistake. There is no excuse today for producing poor-looking printed documented. Check the spelling, first
  automatically and then by hand.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Involve Your Audience

- The documents we produce can often end up being less important than the process we go through to produce them. If
  possible, provide readers with early drafts of your document. Get their feedback, and pick their brains. You'll
    build a good working relationship and produce a better document.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Be a Listener

- Listen to people if you want people to listen to you.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Encourage people to talk by asking questions, or ask them to restate the discussion in their own words. Turn the
  meeting into a dialogue, and you'll make your point more effectively.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Get Back to People

- Always respond to people, even if the response is simple "I'll get back to you later." Keeping people informed makes
  them far more forgiving of the occasional slip, and them feel like you haven't forgotten them.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 12: It's Both What You Say and the Way You Say It

- Unless you work in a vacuum, you need to be able to communicate. The more effective that communication, the more
  influential you become.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Communication Through Documentation

- Typically, developers don't give much though to documentation. At best, it is an unfortunate necessity. At work, it
  is treated as a low-priority task that will hopefully be forgotten.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Pragmatic Programmers embrace documentation as an integral part of the overall development process. Writing
  documentation can be made easier by not duplicating effort or wasting time.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 13: Build Documentation In, Don't Bolt It On

- It's easy to produce good-looking documentation from the comment in source code. Restrict non-API commenting to
  discussing why something is done, it's purpose and goal. The code already shows how it is done, so commenting on this
  is redundant, and a violation of the DRY principle.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Communicate)

- Make a point to read some of the many good books on communications between teams.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The next time you have to give a presentation, or write a message advocating some position, try working through the
  advice in this section before you start.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

### A Pragmatic Approach

- There are certain tips and tricks that apply at all levels of software development, processes that are virtually
  universal, and ideas that are almost axiomatic. However, these approaches are rarely documented; you'll mostly find
  them written down as odd sentences in discussions of design, project management, or coding.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### The Essence of Good Design

- The world is full of gurus and pundits, all eager to share their hard-earned wisdom when it comes to How to Design
  Software.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 14: Good Design is Easier to Change Than Bad Design

- A thing is well-designed if it adapts to the people who use it. For code, that means it must adapt by changing.
  Therefore, that means the ETC (Easier to Change) principle is required.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Every design principle out there is a special case of ETC, such as the single responsibility principle, decoupling,
  good naming.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### ETC is a Value, Not a Rule

- Values are things that help you make decisions. When it comes to software, ETC is a guide, helping you choose between
  paths.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- It requires some initial conscious reinforcement. You may ned to spend a week or so deliberately asking yourself when
  you work on things, such as saving a file, writing a test, fixing a bug.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The ETC principle assumes that a person can tell which of many paths will be easier to change in the future.
  Sometimes, however, you won't have a clue. In those cases, you can do two things:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Try to make what you write replaceable. That way, that chunk of code won't be a roadblock. That approach will also
    help keep code decoupled and cohesive.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Treat the opportunity to develop your instincts. Note the situation, the choices you have, and some guesses about
    change.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (The Essence of Good Design)

- Consider if a design principle you use regularly makes things easy to change.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Think about languages and programming paradigms (object-oriented, functional programming, reactive, etc.) Do they
  have either major positives or negatives when it comes to helping writing ETC code? Do any have both?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When coding, what can you do to eliminate the negatives and accentuate the positives?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Get your editor to create a prompt when you save a file and use it as a cure to consider the code you wrote. Is it
  easy to change?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### DRY - The Evils of Duplication

- As programmers, we collect, organise, maintain, and harness knowledge. We document knowledge in specifications, we
  make it come alive in running code, and we use it to provide the checks needed during testing.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Unfortunately, knowledge isn't stable. It changes - often rapidly. All this instability means that we spend a large
  part of time in maintenance mode, reorganising and re-expressing the knowledge in our systems.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Programmers are constantly in maintenance mode. Our understanding constantly changes and often our tools, the
  development environment, the people around us, etc. Whatever the reason, maintenance is not a discrete activity, but
  a routine part of the entire development process.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- When we perform maintenance, we have to find and change the representations of things - those capsules of knowledge
  embedded in the application. It is too easy to duplicate knowledge in the specifications, processes, and programs
  that we develop, and when we do so, we invite a maintenance nightmare - one that starts well before the delivery of
  the application.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The DRY principle: Every piece of knowledge must have a single, unambiguous, authoritative representation within a
  system.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 15: DRY - Don't Repeat Yourself

- If the same thing is expressed in multiple places, and you have to make an update, it isn't a question of whether
  you'll remember to remember every instance, it's a question of when you'll forget.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### DRY is More Than Code

- DRY is about the duplication of knowledge, or intent. It's about expressing the same thing in two difference places,
  possibly in two totally different ways.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Duplication in Code

- Here's an example of code duplication:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  ```python
  def print_balance(account)
    printf "Debits: %10.2f\n", account.details
    printf "Credits: %10.2f\n", account.credits

    if account.fees < 0
      printf "Fees: %10.2f-\n", -account.fees
    else
      printf "Fees: %10.2f\n", account.fees
    end

    printf "-------\n"

    if account.balance < 0
      printf "Balance: %10.2f-\n", -account.balance
    else
      printf "Balance: %10.2f\n", account.balance
    end
  ```

###### Not All Code Duplication is Knowledge Duplication

- The following is not an example of a duplication, as although the code is the same, the knowledge they represent is
  different. The two functions in the example validate two separate things, but just happen to have the same rules.
  That's coincidence, not a duplication.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  ```python
  def validate_age(value):
    validate_type(value, :integer)
    validate_min_inter(value, 0)

  def validate_quantity(value):
    validate_type(value, :integer)
    validate_min_integer(value, 0)
  ```

##### Duplication in Documentation

- A comment that explains the functionality in source code is unnecessary duplication. It is almost certain that the
  comment and the code will be inconsistent with each other.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### DRY Violations in Data

- The following data structure represents knowledge, but it can fall afoul of the DRY principle:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  ```java
  class Line {
    Point start;

    Point end;

    double length;
  }
  ```

- The following code example removes the duplication from the previous code block:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  ```java
  class Line {
    Point start;

    Point end;

    double length() {
      return start.distanceTo(end);
    }
  }
  ```

- Later in the development process, you may choose to violate the DRY principle for performance reasons. This can occur
  to avoid repeating expensive operations. The trick is to localise the impact. The violation is not exposed outside
  the class containing the violation: only the methods within the class have to worry about keeping things consistent.
  This is illustrated in the following code block:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  ```java
  class Line {
    private double length;

    private Point start;

    private Point end;

    public Line(Point start, Point end) {
      this.start = start;

      this end = end;

      calculateLength();
    }

    void setStart(Point point) {
      this.start = point;

      calculateLength();
    }

    void setEnd(Point point) {
      this.end = point;

      calculateLength();
    }

    Point getStart() {
      return start;
    }

    Point getEnd() {
      return end;
    }

    double getLength() {
      return length;
    }

    private void calculateLength() {
      this.length = start.distanceTo(end);
    }
  }
  ```

- When a module exposes a data structure, you're coupling all that code that uses that structure to that module's
  implementation. Aim to always use accessor functions to read and write the attributes to objects. It will make it
  easier to add functionality in the future. This can also be seen in the example in the previous code block.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Representational Duplication

- Your code interfaces to the outside world. Each time the code externally, you introduce some kind of DRY violation:
  your code has to have knowledge that is also present in that external client. It needs to know the API, or the
  schema, or the meaning of error code, etc. Change the information at one end, and the other end breaks. This
  duplication is inevitable, but there are ways to mitigate it.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Duplication Across Internal APIs

- Look for tools that let you specify the API in some kind of neutral format. These tools will typically generate
  documentation, mock APIs, functional tests, and API clients.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Duplication Across External APIs

- Public APIs are typically documented formally using something like OpenAPI. This allows you to import the API
  specification into your local API tools and integrate more reliably with the service. Consider creating and
  publishing one if you can't find such a specification.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Duplication within Data Sources

- Rather than manually creating the code to contain stored data, you can generate the contains from the schema. Many
  persistence frameworks will do the heavy lifting for you.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Interdeveloper Duplication

- This is perhaps the hardest type of duplication to detect, handle, and mitigate.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Entire sets of functionality may be inadvertently duplicated, and that duplication could go undetected for years,
  leading to maintenance problems.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- At a high level, address the problem by building a strong, tight-knit team with good communication.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- At a module level in code, the problem can be more insidious, commonly needed functionality or data that doesn't fall
  into an obvious area of responsibility can get implemented many times over across a project.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Appoint a team member as the project librarian, whose job is to facilitate the exchange of knowledge in and out of
  the team. Make a point of reading other people's source code and documentation, either informally or during code
  reviews. Use that as an opportunity to learn from them.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 16: Make It Easy to Rescue

- You are aiming to foster an environment where it's easier to find and reuse existing stuff than to write it yourself.
  If it isn't easy, people won't do it. If you fail to reuse, you risk duplicating knowledge.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Orthogonality

- Orthogonality is a critical concept if you want to produce systems that are easy to design, test, and extend.
  Unfortunately, the concept of orthogonality is rarely taught directly, it is often a an implicit feature of various
  other methods and techniques you may learn.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### What is Orthogonality?

- "Orthogonality" is a term borrowed from geometry. Two lines are orthogonal if they meet at right angles. As one line
  moves along the *x* axis, it doesn't change its *y* position. As the other line moves along the *y* axis, it doesn't
  change its *x* position.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- In computing, the term signifies a kind of independency or decoupling. Multiple things are orthogonal if changes in
  one do not affect any of the others. In a well-designed system, the database code will be orthogonal to the user
  interface.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Benefits of Orthogonality

- Non-orthogonal systems are inherently more complex to change and control. When components of a system are highly
  interdependent, there is no such thing as a local or a small fix.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 17: Eliminate Effects Between Things

- When components are isolated from one another, you know you can one without having to worry about the rest. As long
  as you don't change that component's external interfaces, you can be confident that you won't have any impacts that
  propagate throughout the entire system.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Gain Productivity

- **Localised Changes**:

  - It is easier to write relatively small, self-contained components than a single large block of code. Simple
    components can be more easily designed, coded, tested, and then forgotten.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Promotes Reuse**:

  - If components have specific, well-defined responsibilities, they can be contained with new components in ways that
    were originally envisioned by the authors of the original components.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Increased Code Effectiveness**:

  - Assume that one component does *M* distinct things and another does *N* things. If they are orthogonal and you
    combine then, the result does *M * N* things. You get more functionality per unit of effort by combining orthogonal
    components.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Reduce Risk

- **Isolated Code**:

  - Segments of code with issues are separate in an orthogonal system from the rest of the system's code, which would
    also be organised orthogonally. Isolated segments of code also make it easier to replace the code without any
    issues.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Greater Stability**:

  - The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you
    generate will be restricted to that area.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Better Testing**:

  - The system will most likely be better tested, as it will be easier to design and run tests on its components.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Greater Flexibility**:

  - You will not be tied to a particular vendor, product, or platform, as the interfaces to third-party components will
    be isolated to smaller parts of the overall development.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Design

- Most developers are already familiar with the need to design orthogonal systems, although they may use terms such as
  modular, component-based, and layered to describe the project structure and the process to create software.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There is an easy test for orthogonal design. Once you have your components mapped out, "If I dramatically change the
  requirements behind a particular function, how many modules are affected?" In an orthogonal system, the answer should
  be one, or as close to one as possible. Moving a button on a GUI panel should not require a change in the database
  schema. Adding context-sensitive help should not change the billing subsystem.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a
  customer identifier? What happens when the company reassigns area code? Postal code, Social Security Numbers, or
  government IDs, email addresses, and domains are all external identifiers that you have no control over, and could
  change at any time for any reason. Don't rely on the properties of things you can't control.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Toolkits & Libraries

- Be careful to preserve the orthogonality of your system as you introduce third-party toolkits and libraries. Choose
  your technologies wisely. When you bring in a toolkit or library, ask yourself whether it imposes changes on your
  code that shouldn't be there. If an object persistence scheme is transparent, then it's orthogonal. If it required
  you to create or access objects in a special way, then it's not. Keeping such details isolated from your code has the
  additional benefit of making it easier to change vendors in future.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Coding

- You run the risk of reducing the orthogonality of your application every time you write code. You need to constantly
  monitor the larger context of the application to ensure you do not inadvertently reduce the application's
  orthogonality.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There are several techniques you can use to main orthogonality:
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Keep Your Code Decoupled**:

    - Write shy code - modules that don't reveal anything unnecessary to other modules, and that don't rely on other
      modules' implementations. This way your code remains isolated from the other code's implementation and increases
      the chances you'll remain orthogonal.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Avoid Global Data**:

    - Every time your code references global data, it tiers itself into the other components that share the data.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

    - Generally, your code is easier to understand and maintain if you explicitly pass any required context into your
      modules.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

    - The Singleton pattern is a way of ensuring there is only one instance of an object of a particular class. Many
      people use these singleton objects as a kind of global variable. Be careful with singletons - they can lead to
      unnecessary linkage.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - **Avoid Similar Functions**:

    - You'll often come across a set of functions that all look similar - possibly sharing common code at the start and
      end, but each has a different central algorithm. Duplicate code is symptom of structural problems that can be
      addressed with the Strategy pattern.
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Habitually be critical of your code. Identify and opportunities to reorganise it to refactor the project (to improve
  its structure and orthogonality).
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Testing

- An orthogonally designed and implemented system is easier to test. More of the testing can be performed at the
  individual module level, as the interactions between the system's components are formalised and limited.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Writing unit tests is a good test of orthogonality. If there's a large amount of setup required to write a unit test,
  then the module being tested is not well decoupled from the rest of the system.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Bug fixing is also a good time to assess a system's orthogonality. When you come across a problem, assess how
  localised the fix is. Do you change just one module, or are the changes scattered throughout the entire system? When
  you make a change, does it fix everything, or do other problems mysteriously arise?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Orthogonality Through Documentation

- Orthogonality also applies to documentation. Content and presentation are the focus areas. With truly orthogonal
  documentation, you should be able to change the appearance dramatically without changing the content. Word processors
  provide style sheets and macros to help with that. Markup systems such as Markdown are recommended.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Living with Orthogonality

- Orthogonality is closely related to the DRY principle. With DRY, you're looking to minimise duplication within a
  system, whereas with orthogonality you reduce the interdependency among the system's components.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Challenges (Living with Orthogonality)

- Consider the difference between tools which gave a GUI and small but combinable command-line utilities used at shell
  prompts. Which set is more orthogonal, and why? Why set is easier to combine with other tools to meet new challenges?
  Which set is easier to learn?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Is there a difference in impact between multiple inheritance and multiple interfaces? Is there a difference between
  using delegation and using inheritance?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

###### Exercises (Living with Orthogonality)

###### Exercise 1

- **Exercise 1**:

  - You're asked to read a file a line at a time. For each line, you have to split it into fields. Which of the
    following sets of pseudo class definitions is likely to be more orthogonal?
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

    - Example A:
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

      ```js
      class SplitA {
        constructor(fileName)   # Splits a line
        def readNextLine()      # Moves to the next line
        def getField(n)         # Returns nth field in current line
      }
      ```

    - Example B:
      [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
        #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

      ```js
      class SplitB {
        constructor(line)     # Splits a line
        def getField(n)       # Returns nth field in current line
      }
      ```

- **Answer 1**:

  - The class `SplitB` is more orthogonal. It only focuses on its own task- - splitting lines - and ignores details
    such as where the lines are coming from. This makes the code easier to develop and makes it more flexible for
    reuse.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Exercise 2**:

  - What are the differences in orthogonality between object-oriented and functional languages? Are these differences
    inherent in the languages themselves or just in the way people use them?
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- **Answer 2**:

  - You can write good, orthogonal code in almost any language.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - Every language has temptations: features that can lead to increased coupling and decreased orthogonality.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - In object-oriented languages, features such as multiple inheritance, exceptions, operator overloading and
    parent-method overriding (via sub-classing) provide many ways of accidentally increasing coupling in non-obvious
    ways. Coupling classes to data is another form of coupling. If you don't make your classes focused enough, it can
    lead to interfaces with too many parameters and/or functions.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

  - In functional languages, you're encouraged to write lots of small, decoupled functions, and to combine them in
    different ways to solve your problem. This is usually a way of increasing orthogonality, but there is a form of
    coupling that can occur in functional languages. These functions typically transform data, meaning the result of
    one function can become the input to another. If you're not careful, making a change to the data format a function
    generates can result in a failure elsewhere. Languages with good type systems can help mitigate this.
    [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
      #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Reversibility

- Engineers prefer simple, singular solutions to problems.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- There is always more than one way to implement something. There is usually more than one vendor to provide a
  third-party product. You may be surprised if you are convinced there is only one way to implement or use something.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- As time goes by, and your project progresses, you may find yourself stuck in an untenable position. With every
  critical decision, the project team commits to a smaller target - a narrow version that has fewer options. The
  0problem is that critical decisions aren't reversible.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- Many of the topics in this book are tailored to producing flexible, adaptable software. By sticking to this book's
  recommendations, we don't have to make as many critical, irreversible decisions. This is a good thing, as we don't
  always make the best decisions the first time around. Another source of change is that the requirements, users, and
  hardware change faster than we can get the software developed.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- The mistake in making decisions that will be hard is change comes from the assumption that any decision is cast in
  stone - and in not preparing for the contingencies that might arise. Instead of carving decisions in stone, think of
  them more as being written in the sand at the beach. A big wave can come along and wipe them out at any time.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 18: There Are No Final Decisions

- While many people try to keep their code flexible, you also need to think about maintaining flexibility in areas of
  architecture, deployment, and vendor integration.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

- You can't plan for architectural volatility, but what you can do is make it easy to change. Hide third-party APIs
  behind your own abstraction layers. Break your code into components; even if you end up deploying them on a single
  server, this approach is a lot easier than splitting a monolithic application.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Tip 19: Forego Following Fads

- No one knows what the future may hold, especially not us. Enable your code to rock-n-roll: to "rock on" when it can,
  and to "roll with the punches" when it must.
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

##### Challenges (Reversibility)

- Suppose you have a cat in a closed box, along with a radioactive particle. The particle has exactly a 50% change of
  fissioning into two. If it does, the cat will be killed. If it doesn't, the cat will be okay. According to
  Schrdinger, the cat is both dead and alive. Every time a subnuclear reaction takes place that has two possible
  outcomes, the universe is cloned. In one, the event occurred, in the other it didn't. It is only when you open the
  box do you know which universe you are in. Think of code evolution along the same lines as a box full of
  Schrdinger's cats: every decision results in a different version of the future. How many possible futures can your
  code support? Which ones are more likely? How hard would it to be support them when the time comes?
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition)

#### Tracer Bullets

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Prototypes & Post-It Notes

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Domain Languages

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Estimating

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### The Basic Tools

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### The Power of Plain Text

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Shell Games

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Power Editing

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Version Control

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Debugging

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Text Manipulation

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Engineering Daybooks

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### Pragmatic Paranoia

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Design by Contract

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Dead Programs Tell No Tales

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Assertive Programming

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### How to Balance Resources

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Don't Outrun Your Headlights

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### Bend, or Break

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Decoupling

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Juggling the Real World

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Transforming Programming

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Inheritance Task

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Configuration

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### Concurrency

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Breaking Temporal Coupling

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Shared State is Incorrect State

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Actors & Processes

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Blackboards

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### While You Are Coding

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Listen to Your Lizard Brain

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Programming by Coincidence

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Algorithm Speed

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Refactoring

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Test to Code
<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Property-Based Testing
<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Stay Safe Out There

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Naming Things

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### Before the Project

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### The Requirements Pit

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Solving Impossible Puzzles

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Working Together

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### The Essence of Agility

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

### Pragmatic Projects

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Pragmatic Teams

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Coconuts Don't Cut It

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Pragmatic Starter Kit

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Delight Your Users

<!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

#### Pride & Prejudice

<!-- <!-- - 
  [The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition](
    #the-pragmatic-bookshelf-the-pragmatic-programmer-20th-anniversary-edition) -->

</details>

# Online Notes

<!-- ## Application Architecture

### Monolith

### Microservice -->

<!-- ## Communication Protocols

### TCP

### UDP -->

## Databases

### Database Management

#### Sharding

##### What is Database Sharding?

- **Sharding**

  - A method for distributing a single dataset across multiple databases that can be stored on multiple machines.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - Allows for larger databases to be split into smaller chunks and stored in multiple data nodes.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - A form of horizontal scaling, as additional nodes are included to share the database load. In contract, vertical
    scaling refers to increasing the power of a single machine or single server through improved hardware or increased
    storage. [Mongodb: Database Sharding](#mongodb-database-sharding)

<details open>

<summary>Click to expand/minimise the additional details on database sharding.</summary>

##### Do You Need Database Sharding?

- **Vertical scaling**

  - Upgrading your database hardware can be a simple solution to improve the performance or storage capacity of your
    database, without the complexity of sharding.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - The database architecture or application architecture will not require an update with vertical scaling.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **Specialised Services or Databases**

  - It may make more sense to simply soft a subset of the burden onto other database providers or even a separate
    database.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - Offloading a particular functionality can make more sense than trying to shard your entire database.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **Replication**
  
  - Useful if your data workload is primarily read-focused. Replication increases availability and read performance,
    while avoiding some of the complexity with database sharding.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - Read performance can be increased either through load balancing or through geo-located query routing.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - Replication increases the workload of write-focused workloads; each write must be copied to every replicated node.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

##### Advantages of Sharding

- **Increased Read/Write Throughput**

  - By distributing the dataset across multiple shards, both read and write operation capacity is increased.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - This advantage only applies when the read and write operations are confined to a single shard.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **Increased Storage Capacity**

  - Increasing the number of shards can increase overall storage capacity, allowing near-infinite scalability.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **High Availability**

  - Since each shard is a replica set, every piece of data is replicated.

  - Even if an entire shard becomes unavailable since the data is distributed, the database as a whole still remains
    partly functional, with part of the schema on different shards.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

##### Disadvantages of Sharding

- **Query Overhead**

  - Each sharded database must have a separate machine or service that understands how to route a querying operation to
    the appropriate shard.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - This increases latency on each operation.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - If the data required for the query is horizontally partitioned across multiple shards, the router must then query
    each shard and merge the result together. This can slow down response times and make simple operations expensive to
    perform.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **Complexity of Administration**

  - A single unsharded database only requires maintenance on the database server itself.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - With every sharded database, there are additional service nodes to maintain.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - When replication is being used, any data updates must be mirrored across each replicated node.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **Increased Infrastructure Costs**

  - Sharding requires additional machine and additional computing power over a single database server.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - Each additional shard comes with higher costs.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - The cost of a distributed system can be significant.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

##### How Does Sharding Work? These Questions Should Be Answered

- **How Will the Data Be Distributed Across Shards?**

  - The fundamental question behind any sharded database. The choice will have impacts on both performance and
    maintenance. See [Sharding Architectures and Types](#sharding-architectures-and-types) for more details.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **What Type of Queries Will Be Routed Across Shards?**

  - Replicating data will be highly effective at increasing performance if your workload is primarily read operations.
    Sharding may not be required.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - A mixed read-write workload or even a primarily write-based workload with require a different architecture.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- **How Will These Shards be Maintained?**

  - In a sharded database, data will need to be periodically redistributed among the various shards. New shards may
    need to be created. This may be an expensive process, depending on how the data is distributed.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

##### Sharding Architectures and Types

###### Ranged/Dynamic Sharding

- Takes a field on the record as an input, and allocated that record to the appropriate shard, based on a predefined
  range. [Mongodb: Database Sharding](#mongodb-database-sharding)

- A lookup table or service is required for all read or writes.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- A shard key is the field on which the range is based. The choice of the shard key is critical in making range-based
  sharding effective:

  - **Poor Choice**: Will lead to unbalanced shards, leading to decreased performance.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - **Effective Choice** Will allow for queries to be targeted to a minimum number of shards.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- Attributes of an effective shard key:

  - **High Cardinality**: Cardinality is the number of possible values of that key. If a shard key only has three
    possible values, the maximum shard count is three.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

  - **Well-Distributed Frequency**: Frequency is the distribution of the data along the possible values. If 95% of
    records occur with a single shard key value, then 95% of the record will be allocated to a single shard.
    [Mongodb: Database Sharding](#mongodb-database-sharding)

- The lookup service can become a bottleneck, although the amount of data is small enough this is typically not an
  issue.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

###### Algorithmic/Hashed Sharding

- A record is provided as an inputs, and a hash function or algorithm is applied to that record to generate an output
  or hash value. This output is used to allocate each record to the appropriate shard.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- The function can take any subset of values on the record as inputs. The following is a simple example.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

  ```text
  Hash Value=ID % Number of Shards
  ```

- Like [Ranged/Dynamic Sharding](#rangeddynamic-sharding), a set of fields determines the allocation of the record to a
  given record. Hashing the inputs allows a more even distribution of shards, even without a suitable shard key. No
  lookup table needs to be maintained.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- [Ranged/Dynamic Sharding](#rangeddynamic-sharding) reflects the natural structure of the data across shards, hashed
  sharding typically disregards the meaning of the data.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- Resharding can be expensive. Any update to the number of shards likely requires rebalancing all shards to move around
  records. This is difficult to perform without a system outage.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

###### Entity-Based/Relationship-Based Sharding

- Data is kept together on a single physical shard. For contrast, related data is often spread across several different
   tables in a relational database.
   [Mongodb: Database Sharding](#mongodb-database-sharding)

- Keeping related data together on the same shard can reduce the need for broadcast operations, increasing performance.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

###### Geography-Based Sharding/Geosharding

- Like [Entity-Based/Relationship-Based Sharding](#entity-basedrelationship-based-sharding), related data is kept
  together in a single shard. The data is related by geography. This is like
  [Ranged/Dynamic Sharding](#rangeddynamic-sharding), where the shard key contains geographic information.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- If each record contains a `country` in the dataset, overall performance can be increased and system latency can be
  decreased, by storing the appropriate data for that `country` in the relevant shard.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

##### Sharding vs Partitioning

- Sharding is a form of partitioning, with an emphasis on locating each shard in a separate physical node.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

- Partitions can co-exist on a single machine.
  [Mongodb: Database Sharding](#mongodb-database-sharding)

</details>

<!-- ## Design/Development Methodologies

### Behaviour-Driven Design/Development

### Domain-Driven Design/Development

### Test-Driven Design/Development -->

<!-- ## Containerisation

### Docker

### LXC

### Podman -->

<!-- ## Delivery Paradigms

### DevOps

### GitOps -->

<!-- ## Deployment

### Container Orchestration Systems

#### Kubernetes

### Declarative Continuous Delivery Tools

#### Argo CD

#### Helmfile

### Package Managers

#### Helm

#### Kustomize

## Hyperscalers

### AWS

### Azure

### Google Cloud -->

<!-- ## File Formats

### .json (JSON)

### .md (Markdown)

### .tar (Tar Archive/Tarball)

### .tgz (GZip Compressed TAR Archive)

### .txt (Plain Text)

### .xml (XML)

### .yaml (YAML)

### .yml (YML)

### .zip (Zip) -->

## Inter-Service Communication

<!-- ### Communication Paradigms

#### HTTP

##### API Design (HTTP)

#### Data Streaming

##### API Design (Data Streaming)

### Data Streaming Platforms

#### Kafka

#### RabbitMQ

### HTTP Protocols

#### REST

#### SOAP -->

### Security

#### Service Mesh

##### Service Mesh Overview

- **Service mesh**

  - A service mesh is configurable, low-latency infrastructure layer designed to handle a high volume of network-based
    interprocess communication among application infrastructure services using APIs.
    [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - It ensures that communication among containerised and often ephemeral application infrastructure services is fast,
    reliable, and secure.
    [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

<details open>

<summary>Click to expand/minimise the additional details on service meshes.</summary>

- **Sidecar**

  - Used for each service instance implement a service mesh, by providing a proxy interface.
    [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - Handles anything that can be abstracted away from the individual services, e.g., inter-service communications,
    monitoring, and security-related concerns.
    [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - Operations teams can maintain the service mesh and run the application, allowing the development teams to handle
    development, support, and maintenance for the service application code.
    [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

- It provides the following component services and functions:

  ![Diagram](https://www.nginx.com/wp-content/uploads/2019/02/service-mesh-generic-topology.png)

  - **Container Orchestration Framework**

    - A separate tool for managing the set of containers in an application's infrastructure.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - Kubernetes is the most common example. [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Services and instances**

    - **Instance**: A single running copy of a microservice.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - **Pod**: A Kubernetes instance. Composed of a small group of interdependent containers.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - **Service**: Used by clients to access an instance or pod. A set of identical instances or pods, that is scalable
      and fault-tolerant.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Sidecar Proxy**

    - Its purpose is to route traffic to and from the container it runs alongside.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - Communicates with other sidecar proxies.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - Managed by the orchestration framework.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - Commonly intercepts and manages all ingress and egress traffic to the instance or pod.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Service Discovery**

    - An instance typically performs a DNS lookup when finding a health, available instance of the other service.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - The container orchestration framework keeps a list of instances that are ready to receive requests and provides
      the interface for DNS queries.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Load Balancing**

    - Most orchestration frameworks already provide transport layer load balancing.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - A service mesh implements more sophisticated application layer load balancing, with richer algorithms and more
      powerful traffic management.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Encryption**

    - The service mesh can encrypt and decrypt requests and responses. It is not required on each service.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

    - **mTLS**: Mutual TLS. When a public key infrastructure (PKI) generates and distributes certificates and keys for
      the sidecar proxies.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Authentication and Authorisation**

    - The service mesh can authorise and authenticate both internal and external application requests. Only validated
      requests are sent to instances.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Support for the Circuit Breaker Pattern**

    - The circuit breaker pattern isolates unhealthy instances, and gradually reintroduces them into the healthy
      instance pool if necessary.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Data Plane**

    - The part of a service mesh application that manages the network traffic between instances.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

  - **Control Plane**

    - Generates and deploys the configuration that controls the data plane's behaviour.
      [Nginx: What Is A Service Mesh?](#nginx-what-is-a-service-mesh)

##### Scenarios for a service mesh

- **Encrypt All Traffic in a Cluster**: Enable mutual TLS between specified services in the cluster. This can be
  extended to ingress and egress requests.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Canary and Phased Rollouts**: Specify conditions for a subset of traffic to be routed to a set of new services in
  the cluster.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Traffic Management and Manipulation**: Create a policy on a service that will rate limit all traffic to a version
  of a service from a specific origin, or a policy that applies a retry strategy to classes of failures between
  specified services.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Observability**: Gain insight into how your services are connected and the traffic that flows between them.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

##### Selection Criteria for Installing a Service Mesh

- **Is an Ingress Controller Sufficient For My Needs?** Traffic splitting at the ingress may be sufficient to support
  the required scenario. Don't add complexity to your environment with no benefit.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Can My Workloads and Environment Tolerate the Additional Overheads?** All the additional components required to
  support the service mesh require additional resources like CPU and memory.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Is this Adding Additional Complexity Unnecessarily?** If the reason for installing a service mesh is to gain a
  capability that is not business-critical, then consider whether the additional complexity is worth it.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

- **Can this be Adopted in an Incremental Approach?** Some of the service meshes that provide a lot of capabilities can
  be adopted in a more incremental approach. Install just the components you need to ensure your success.
  [Microsoft: About Service Meshes](#microsoft-about-service-meshes)

</details>

#### TLS

##### TLS Overview

- **TLS**

  - TLS: Transport Layer Security
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - A security protocol that is used to establish encrypted between a web server and a browser to protect the data
    exchanged between them.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - The successor of Secure Sockets Layer (SSL).
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - Now the most widely-used protocol for securing web communications.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - TLS ensures that data cannot be read or tampered with during transit and that the identity of the communicating
    parties can be verified.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

<details open>

<summary>Click to expand/minimise the additional details on TLS.</summary>

##### How TLS Works

- TLS uses a combination of public-key cryptography and symmetric-key cryptography to achieve its security goals:

  - **Public-key Cryptography**

    - Aka, asymmetric cryptography.
      [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

    - Relies on a pair of keys to decrypt data; a public key and a private key.
      [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

      - The public key can be shared with anyone.
        [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

      - The private key must be kept secret.
        [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - **Symmetric-Key Cryptography**

    - Uses a single shared key to encrypt and decrypt data.
      [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

    - **Advantage**: Much faster than public-key cryptography.
      [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

    - **Disadvantage**: Both parties must securely share the secret key before they can communicate securely.
      [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- When two parties want to establish a secure connection using TLS, they first use public-key cryptography to agree on
  a shared secret key. They can then use symmetric-key cryptography for all further communications using that shared
  secret key. This allows TLS to take advantage of the speed of symmetric-key cryptography, while ensuring the shared
  secret key remains confidential. The shared secret key never needs to be transmitted over the network. It can be
  generated from within each party's own computer.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

##### SSL vs TLS

- SSL was initially developed to secure sensitive information, e.g, credit card numbers and passwords, as it is passed
  around the internet. [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- TLS is based on SSL, but includes a number of security enhancements making it more effective at protecting data.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- TLS provides stronger authentication than SSL, by verifying the identity of the server (like SSL) and the client.
  This two-way authentication helps prevent "man-in-the-middle" attacks; when an attacker intercepts communications
  between a server and a client to impersonate both parties.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- TLS also offers Perfect Forward Secrecy (PFS). If an attacker is able to compromise a private key, they would only be
  able to access data that was encrypted with that key. PFS is achieved by using the Diffie-Hellman exchange to
  generate unique keys for each session.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

##### How Does TLS Affect Web Application Performance?

###### TLS Handshake Protocol

- One of the most common ways that TLS affects web application performance.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- The TLS handshake occurs when two devices first establish a secure communication channel.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- During the handshake, the devices exchange information about their preferred security protocols and cipher suites.
  This adds significant overhead to web applications, especially if the handshake is renegotiated frequently.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

###### Cipher Suites

- **Cipher Suites**: Algorithms used to encrypt communication between two devices.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- Some cipher suites are more resource-intensive than others, which can impact the performance of web applications.
  [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

##### Mitigating the Negative Effects of TLS on Web Application Performance

- **Prioritise Performance Over Security**

  - Use only the encryption algorithms and key sizes that are absolutely necessary to maintain an acceptable level of
    security. [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - 128-bit is sufficient for most applications.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- **Offload Cryptographic Processing**

  - Use hardware accelerators or specialised processors to offload the cryptographic processing required for TLS from
    the main CPU. [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - Can free up valuable CPU resources for other tasks and improve overall system performance.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- **Use Connection Pooling**

  - Connection pooling allows multiple clients to reuse a small number of pre-opened connections.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - Reduces the overhead from opening and closing connections, improving both throughput and latency.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

- **Cache Session IDs**

  - Session IDs can be cached locally to avoid the overhead of performing a full handshake each time a new session is
    needed. [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

  - Most effective for short-lived sessions that are reused frequently.
    [Techradar: What is TLS and How Does it Work?](#techradar-what-is-tls-and-how-does-it-work)

</details>

<!-- ## Pipelines

### Jenkins

### Spinnaker -->

<!-- ## Programming

### Programming Frameworks

#### .NET

#### React

### Programming Languages

#### C\#

#### Erlang

#### Golang

#### JavaScript (Programming)

#### Python (Programming)

#### Rust

#### TypeScript -->

<!-- ## Scripting

### Scripting Languages

#### Bash

#### JavaScript (Scripting)

#### Python (Scripting) -->

<!-- ## Testing

TODO: Order in which to do this testing.

### Compatibility Testing

### Device Testing

#### Backwards Compatibility Testing

#### Forwards Compatibility Testing

#### Software Testing

### Functional Testing

<https://www.browserstack.com/guide/functional-testing>

#### Integration Testing

<https://www.browserstack.com/guide/integration-testing>

#### Regression Testing

<https://www.browserstack.com/guide/regression-testing>

### Sanity Testing

<https://www.browserstack.com/guide/sanity-testing>

### Performance Testing

<https://www.browserstack.com/guide/performance-testing>

#### Endurance Testing

<https://www.browserstack.com/guide/performance-testing>

#### Load Testing

<https://www.browserstack.com/guide/performance-testing>

#### Scalability Testing

<https://www.browserstack.com/guide/performance-testing>

#### Stress Testing

<https://www.browserstack.com/guide/performance-testing>

#### Spike Testing

<https://www.browserstack.com/guide/performance-testing>

#### Volume Testing

<https://www.browserstack.com/guide/performance-testing>

### Smoke Testing

<https://www.browserstack.com/guide/smoke-testing>

#### Unit Testing

<https://www.browserstack.com/guide/unit-testing-a-detailed-guide>

#### Usability Testing

<https://www.browserstack.com/guide/website-usability-testing>

### User Interface Testing

<https://www.browserstack.com/guide/ui-testing-guide>

#### Exploratory Testing

<https://www.browserstack.com/guide/ui-testing-tools-and-techniques>

#### User Experience Testing

<https://www.browserstack.com/guide/ui-testing-tools-and-techniques> -->

## Telecommunications

### Network Slicing

#### What is Network Slicing?

- An operators' best answer on how to build and manage a network, that meets and exceeds the emerging requirements from
  a wide range of users.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- The way to achieve a sliced network is to transform it into a set of logical networks on top of a shared
  infrastructure. Each logical network is designed to serve a defined business purpose and comprises of all the
  required network resources, configured and connected end-to-end.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- The network slice is a logically separated, self-contained, independent and secured part of the network, targeting
  different services with different requirements on speed, latency and reliability. Network slice characteristics
  include low latency, high bandwidth and ultra-reliability for a critical IoT use case or higher latency and lower
  bandwidth for a massive IoT use case.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- To efficiently manage the network slices and to maximise revenues, a modern OSS/BSS
  (Business and Operations Support Systems) providing automated business and operational processes is a must. With
  programmable and flexible 5G networks and advanced AI (Artificial Intelligence) and Service Level Agreement (SLA)
  driven orchestration, the required network functions can be flexibly created, quickly deployed and automatically
  managed throughout the life cycle.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- A network slice can be dedicated to one enterprise customer, or shared by multiple tenants. For example, a slice may
  consist of dedicated radio, transport and core resources including a dedicated user plane function at the edge.
  Another slice shares radio & transport resources between tenants, but provides dedicated core network functions per
  tenant. [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

<details open>

<summary>Click to expand/minimise the additional details on network slicing.</summary>

#### Benefits of Network Slicing

- End-to-end network slicing enables new business model innovation and use cases across all verticals, and creates new
  revenue opportunities for communication service providers. It provides service flexibility and ability to deliver
  services faster with high security, isolation, and applicable characteristics to meet the contracted SLA.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- Network Slicing enables operators to maximise the return on investment via efficient usage and management of the
  network resources and provide differentiated services at scale.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

- As 5G brings new technologies and creates new business opportunities across all industries, enterprises are looking
  for innovative solutions to meet their needs and to address new opportunities. Enterprise users want automated
  business and operational processes starting from ordering the service, activation, delivery and de-commissioning of
  the service. They are expecting services to be delivered faster with high security. With network slicing,
  communication service providers can meet all the needs from their enterprise customers.
  [Ericsson: Navigate the Network Slicing Transformation Journey](
    #ericsson-navigate-the-network-slicing-transformation-journey)

#### How 5G Network Slicing Works

![How 5G Network Slicing Works](https://cdn.ttgtmedia.com/rms/onlineimages/networking-slicing_diagram.png)

#### Network Slicing Use Cases

- Network slicing supports use cases that focus on performance, capacity and security. Many use cases involve the
  business models based on the Internet of Things. Some network slicing use cases involve the following:

  - **Real-Time Performance**

    - A company depending on a 5G network for autonomous vehicle management might contract for a mobile network slice
      with latencies under 5 ms and stringent guarantees of packet delivery on the minimum throughput required to
      ensure responsive control.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

    - The provider would use URLLC (UltraReliable Low-Latency Communications) functionality to guarantee the slice on
      the lowest-latency equipment and paths between vehicles and cloud or edge resources and reserve enough capacity
      to meet the throughput target.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

  - **Capacity**:

    - For a security monitoring system in a large auditorium, latency may not matter, but the security company may want
      to buy guaranteed delivery of the camera data.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

    - In other words, the company would want its traffic to get 1.5 megabits per second of throughput per camera with
      no packets dropped, ever.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

    - The provider might aggregate multiple connectivity and processing device options to meet the needs of this slice.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

  - **Security**:

    - For a human health monitoring system in a metropolitan area, a hospital might want to isolate all traffic to and
      from pacemakers.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

    - This would minimise the risk of a leak of customer data and the threat of compromise of the control channel - so
      it would require a slice with single-user virtual resources.
      [Tech Target: Network Slicing](#tech-target-network-slicing)

</details>

<!-- ## Version Control

### Code Collaboration Platforms

#### Gerrit

#### GitHub

##### GitHub Automation

###### Dependabot

###### GitHub Actions

#### GitLab

### Repository

#### Centralised

##### CVS

##### Perforce

##### Subversion

#### Distributed

##### Mercurial

##### Git -->

<!--

## Template

### Overview ()

### Tool Comparison ()

### Detailed Overview ()

-->

<!-- To Do:
- Design Patterns
- Code Reviews
- Microservice Architecture
- Code Smells
- Static Analysis
- Code Coverage
- Testing
- HA
- GA
- BUR
- Java Version Features
- RAN
- Software Role - DevOps vs Software Engineer
- Documentation
- Agile Ceremonies
- Scrum
- Agile
- Waterfall
- MTLS
- Telecommunications
- vi
- nano
- vim
 -->

# References

## Ericsson

### Ericsson: Navigate the Network Slicing Transformation Journey

- <https://www.ericsson.com/en/network-slicing>

## Microsoft

### Microsoft: About Service Meshes

- <https://learn.microsoft.com/en-us/azure/aks/servicemesh-about>

## Mongodb

### Mongodb: Database Sharding

- <https://www.mongodb.com/features/database-sharding-explained>

## Nginx

### Nginx: What Is A Service Mesh?

- <https://www.nginx.com/blog/what-is-a-service-mesh/>

## O'Reilly

### O'Reilly: 97 Things Every Programmer Should Know

- <https://www.oreilly.com/library/view/97-things-every/9780596809515/>

### O'Reilly: *bash* Cookbook, 2nd Edition

- <https://www.oreilly.com/library/view/bash-cookbook-2nd/9781491975329/>

## Tech Target

### Tech Target: Network Slicing

- <https://www.techtarget.com/whatis/definition/network-slicing>

## Techradar

### Techradar: What is TLS and How Does it Work?

- <https://www.techradar.com/features/what-is-tls-and-how-does-it-work>

## The Pragmatic Bookshelf

### The Pragmatic Bookshelf: The Pragmatic Programmer, 20th Anniversary Edition

- <https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/>
